<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SnpSift</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Styles -->
    <link href="css/bootstrap.css" rel="stylesheet">
    <link href="css/bootstrap-responsive.css" rel="stylesheet">
    <link href="css/docs.css" rel="stylesheet">
    <link href="js/google-code-prettify/prettify.css" rel="stylesheet">
	<link href="css/my.css" rel="stylesheet">

    <!-- hTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="js/html5shiv.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="ico/apple-touch-icon-114-precomposed.png">
      <link rel="apple-touch-icon-precomposed" sizes="72x72" href="ico/apple-touch-icon-72-precomposed.png">
                    <link rel="apple-touch-icon-precomposed" href="ico/apple-touch-icon-57-precomposed.png">
                                   <link rel="shortcut icon" href="ico/favicon.png">

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66345247-1', 'auto');
  ga('send', 'pageview');

</script>
  </head>

  <body data-spy="scroll" data-target=".bs-docs-sidebar">

    <!-- Navbar
    ================================================== -->
    <div class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="#">SnpSift</a>
          <div class="nav-collapse collapse">
            <p class="navbar-text pull-right">
            </p>
            <ul class="nav">
              <li class="active"><a href="index.html">Home</a></li>
              <li><a href="download.html">Download</a></li>
              <li><a href="SnpEff_manual.html">Documentation</a></li>
              <li><a href="SnpSift.html">SnpSift</a></li>
              <li><a href="about.html">About</a></li>
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

<!-- Subhead
================================================== -->
<header class="jumbotron subhead" id="overview">
  <div class="container">
    <h1>SnpSift</h1>
    <p class="lead">Filter and manipulate annotated files</p>
  </div>
</header>


  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span3 bs-docs-sidebar">
        <ul class="nav nav-list bs-docs-sidenav">
          <li><a href="#intro"> <i class="icon-chevron-right"></i> Introduction</a></li>
          <li><a href="#filter"> <i class="icon-chevron-right"></i> SnpSift filter </a></li>
          <li><a href="#annotate"> <i class="icon-chevron-right"></i> SnpSift Annotate </a></li>
          <li><a href="#casecontrol"> <i class="icon-chevron-right"></i> SnpSift CaseControl </a></li>
          <li><a href="#Intervals"> <i class="icon-chevron-right"></i> SnpSift Intervals </a></li>
          <li><a href="#intidx"> <i class="icon-chevron-right"></i> SnpSift Intervals Index </a></li>
          <li><a href="#Join"> <i class="icon-chevron-right"></i>  SnpSift Join </a></li>
          <li><a href="#RmRefGen"> <i class="icon-chevron-right"></i>  SnpSift RmRefGen </a></li>
          <li><a href="#TsTv"> <i class="icon-chevron-right"></i>  SnpSift TsTv </a></li>
          <li><a href="#Extract"> <i class="icon-chevron-right"></i>  SnpSift Extract Fields </a></li>
          <li><a href="#VariantType"> <i class="icon-chevron-right"></i>  SnpSift Variant type </a></li>
          <li><a href="#gwasCatalog"> <i class="icon-chevron-right"></i>  SnpSift GWAS Catalog </a></li>
          <li><a href="#dbNSFP"> <i class="icon-chevron-right"></i>  SnpSift dbNSFP </a></li>
          <li><a href="#Split"> <i class="icon-chevron-right"></i>  SnpSift Split</a></li>
          <li><a href="#phastCons"> <i class="icon-chevron-right"></i>  SnpSift PhastCons</a></li>
          <li><a href="#concordance"> <i class="icon-chevron-right"></i>  SnpSift Concordance</a></li>
          <li><a href="#private"> <i class="icon-chevron-right"></i>  SnpSift Private</a></li>
          <li><a href="#vcf2tped"> <i class="icon-chevron-right"></i>  SnpSift Vcf2Tped</a></li>
          <li><a href="#intersect"> <i class="icon-chevron-right"></i>  SnpSift Intersect</a></li>
          <li><a href="#rmInfo"> <i class="icon-chevron-right"></i>  SnpSift RmInfo</a></li>
          <li><a href="#geneSets"> <i class="icon-chevron-right"></i>  SnpSift GeneSets</a></li>
          <li><a href="#gt"> <i class="icon-chevron-right"></i>  SnpSift GT</a></li>
          <li><a href="#vcfCheck"> <i class="icon-chevron-right"></i>  SnpSift VcfCheck</a></li>
        </ul>
      </div>
      <div class="span9">


        <!-- Introduction
        ================================================== -->
        <section id="intro">
          <div class="page-header">
            <h1>1. Introduction</h1>
          </div>
				<p class="lead">
				SnpSift is a toolbox that allows you to filter and manipulate annotated files. 
				</p>

				For older version of this page, see: <a href="SnpSift.version_4_0.html">Manual page for SnpSift version 4.0</a><p>

				<p>
				Once your genomic variants have been annotated, you need to filter them out in order to find the "interesting / relevant variants".
				Given the large data files, this is not a trivial task (e.g. you cannot load all the variants into XLS spreadsheet).
				SnpSift helps to perform this VCF file manipulation and filtering required at this stage in data processing pipelines.
				</p>

            <h3>Download and install</h3>
				<p> SnpSift is part of SnpEff main distribution, so please click on <a href="download.html">here</a> and follow the instructions on how to download and install SnpEff.
				</p>

            <h3>SnpSift utilities</h3>
				<p> SnpSift is a collection of tools to manipulate <a href="http://www.1000genomes.org/wiki/Analysis/Variant%20Call%20Format/vcf-variant-call-format-version-41">VCF</a> (variant call format) files.<br>
				Some examples of what you can do:
				<table class="table table-striped">
					<tr> <td> <b>Filter</b> </td> <td> You can filter using arbitrary expressions, for instance "(QUAL &gt; 30) | (exists INDEL) | ( countHet() &gt; 2 )". The actual expressions can be quite complex, so it allows for a lot of flexibility. </td> </tr>
					<tr> <td> <b>Annotate</b> </td> <td> You can add 'ID' and INFO fields from another "VCF database" (e.g.  typically dbSnp database in VCF format). </td> </tr>
					<tr> <td> <b>CaseControl</b> </td> <td> You can compare how many variants are in 'case' and in 'control' groups. Also calculates p-values (Fisher exact test). </td> </tr>
					<tr> <td> <b>Intervals</b> </td> <td> Filter variants that intersect with intervals. </td> </tr>
					<tr> <td> <b>Intervals (intidx)</b> </td> <td> Filter variants that intersect with intervals. Index the VCF file using memory mapped I/O to speed up the search. This is intended for huge VCF files and a small number of intervals to retrieve. </td> </tr>
					<tr> <td> <b>Join</b> </td> <td> Join by generic genomic regions (intersecting or closest). </td> </tr>
					<tr> <td> <b>RmRefGen</b> </td> <td> Remove reference genotype (i.e. replace '0/0' genotypes by '.') </td> </tr>
					<tr> <td> <b>TsTv</b> </td> <td> Calculate transition to transversion ratio. </td> </tr>
					<tr> <td> <b>Extract fields</b> </td> <td> Extract fields from a VCF file to a TXT (tab separated) format. </td> </tr>
					<tr> <td> <b>Variant type</b> </td> <td> Adds SNP/MNP/INS/DEL to info field. It also adds "HOM/HET" if there is only one sample. </td> </tr>
					<tr> <td> <b>GWAS Catalog</b> </td> <td> Annotate using GWAS Catalog. </td> </tr>
					<tr> <td> <b>DbNSFP</b> </td> <td> Annotate using dbNSFP: The dbNSFP is an integrated database of functional predictions from multiple algorithms (SIFT, Polyphen2, LRT and MutationTaster, PhyloP and GERP++, etc.) </td> </tr>
					<tr> <td> <b>SplitChr</b> </td> <td> Split a VCF file by chromosome </td> </tr>
				</table>
				</p>

            <h3>Citing SnpSift</h3>
				<p> In order to cite SnpSift, please use the following reference: <br>

				<blockquote>
				"Using Drosophila melanogaster as a model for genotoxic chemical mutational studies with a new program, SnpSift", Cingolani, P., et. al., Frontiers in Genetics, 3, 2012.<br>
				</blockquote>

				BibTex entry: 
<pre>
@article{cingolani2012using,
  title={Using Drosophila melanogaster as a model for genotoxic chemical mutational studies with a new program, SnpSift},
  author={Cingolani, P. and Patel, V.M. and Coon, M. and Nguyen, T. and Land, S.J. and Ruden, D.M. and Lu, X.},
  journal={Frontiers in Genetics},
  volume={3},
  year={2012},
  publisher={Frontiers Media SA}
}
</pre>
				</p>
				
            <h3>Source code</h3>
				<p> The project is hosted at SourceForge. </p>
				Here is the SVN command to check out the development version of the code:
<pre>
svn co https://snpeff.svn.sourceforge.net/svnroot/snpeff/SnpSift/trunk
</pre>

        </section>


        <!-- Filter
        ================================================== -->
        <section id="filter">
          <div class="page-header">
            <h1>2. SnpSift filter </h1>
          </div>
				<p class="lead">
				SnpSift filter is one of the most useful SnpSift commands.
				Using SnpSift filter you can filter VCF files using arbitrary expressions, for instance "(QUAL &gt; 30) | (exists INDEL) | ( countHet() &gt; 2 )". The actual expressions can be quite complex, so it allows for a lot of flexibility.<p>
				</p>

				Some examples for the impatient:
				<ul>
					<li> I want to filter out samples with quality less than 30:
					<pre> cat variants.vcf | java -jar SnpSift.jar filter " ( QUAL >= 30 )" > filtered.vcf</pre>

					<li> ...but we also want InDels that have quality 20 or more:
					<pre> cat variants.vcf | java -jar SnpSift.jar filter "(( exists INDEL ) & (QUAL >= 20)) | (QUAL >= 30 )" > filtered.vcf</pre>

					<li> ...or any homozygous variant present in more than 3 samples:
					<pre> cat variants.vcf | java -jar SnpSift.jar filter "(countHom() > 3) | (( exists INDEL ) & (QUAL >= 20)) | (QUAL >= 30 )" > filtered.vcf</pre>

					<li> ...or any heterozygous sample with coverage 25 or more:
					<pre> cat variants.vcf | java -jar SnpSift.jar filter "((countHet() > 0) && (DP >= 25)) | (countHom() > 3) | (( exists INDEL ) & (QUAL >= 20)) | (QUAL >= 30 )" > filtered.vcf</pre>

					<li> I want to keep samples where the genotype for the first sample is homozygous variant and the genotype for the second sample is reference:
					<pre> cat variants.vcf | java -jar SnpSift.jar filter "isHom( GEN[0] ) & isVariant( GEN[0] ) & isRef( GEN[1] )" > filtered.vcf</pre>

					<li> I want to keep samples where the ID matches a set defined in a file:
					<pre> cat variants.vcf | java -jar SnpSift.jar filter --set my_rs.txt "ID in SET[0]" > filtered.vcf</pre>
					and the file my_rs.txt has one string per line, e.g.:
					<pre>rs58108140
rs71262674
rs71262673</pre> 
				</ul>

				You can combine any conditions you want using boolean operators. <p>

				<h3>Command line opions</h3> 
<pre>
Usage: java -jar SnpSift.jar filter [options] 'expression' [input.vcf]
Options:
	-a|--addFilter <str>  : Add a string to FILTER VCF field if 'expression' is true. Default: '' (none)
	-e|--exprFile <file>  : Read expression from a file
	-f|--file <input.vcf> : VCF input file. Default: STDIN
	-i|--filterId <str>   : ID for this filter (##FILTER tag in header and FILTER VCF field). Default: 'SnpSift'
	-n|--inverse          : Inverse. Show lines that do not match filter expression
	-p|--pass             : Use 'PASS' field instead of filtering out VCF entries
	-r|--rmFilter <str>   : Remove a string from FILTER VCF field if 'expression' is true (and 'str' is in the field). Default: '' (none)
	-s|--set <file>       : Create a SET using 'file'
	--errMissing          : Error is a field is missing. Default: false
	--format <format>     : SnpEff format version: {2, 3}. Default: Auto
	--galaxy              : Used from Galaxy (expressions have been sanitized).
</pre>

				<h3>Variables</h3> 
				All VCF fields can be used as variables names, as long as they are declared in the VCF header OR they are "standard" VCF fields (as defined by the VCF 4.1 specification).
				<br>
				<ul>
					<li> <b>Fields</b> names: "CHROM, POS, ID, REF, ALT, QUAL or FILTER"
						Examples:
						<ul>
							<li> Any variant in chromosome 1: <pre> "( CHROM = 'chr1' )" </pre>
							<li> Variants between two positions: <pre> "( POS > 123456 ) & ( POS < 654321 )" </pre>
							<li> Has an ID and it matches the regulat expression 'rs': <pre> "(exists ID) & ( ID =~ 'rs' )" </pre>
							<li> The reference is 'A': <pre> "( REF = 'A' )" </pre>
							<li> The alternative is 'T': <pre> "( ALT = 'T' )" </pre>
							<li> Quality over 30: <pre> "( QUAL > 30 )" </pre>
							<li> Filter value is either 'PASS' or it is missing: <pre> "( na FILTER ) | (FILTER = 'PASS')" </pre>
						</ul>

					<li> <b>INFO field</b> names in the INFO field. E.g. if the info field has "DP=48;AF1=0;..." you can use something like
						<pre> ( DP > 10 ) & ( AF1 = 0 )</pre>
				</ul>

				<h3>Multiple valued fields and variables</h3> 
				When variables have multiple values, you can access individual values as if it was an array.

				<ul>
					<li> <b>Multiple value</b> info fields (comma separated) can be accessed using an index. E.g. If the INFO field has "CI95=0.04167,0.5417" you can use an expression such as 
						<pre> "( CI95[0] > 0.1 ) & (CI95[1] <= 0.3)" </pre>

					<li> <b>Multiple indexes</b> You may test multiple indexed fields using 'ANY' or 'ALL' as index. In the examples we assume the INFO field has "CI95=0.04167,0.5417" <p>
						<b>ANY</b> or <b>*</b>: If you use 'ANY' as index, the expression will be true if any field satisfies the expression.<br>
						So, for instance, the following expressions
						<pre> "( CI95[ANY] > 0.1 )" </pre>
						or
						<pre> "( CI95[*] > 0.1 )" </pre>
						are equivalent to (in this case, there are only two values in the array)
						<pre> "( CI95[0] > 0.1 ) | ( CI95[1] > 0.1 )" </pre>
						<p>
						<b>ALL</b> or <b>?</b>: If you use 'ALL' as index, the expression will be true if all field satisfy the expression.<br>
						So, for instance, the following expressions
						<pre> "( CI95[ALL] > 0.1 )" </pre>
						<pre> "( CI95[?] > 0.1 )" </pre>
						are equivalent to (in this case, there are only two values in the array)
						<pre> "( CI95[0] > 0.1 ) & ( CI95[1] > 0.1 )" </pre>
				</ul>
				<h3> Genotype fields </h3>
				Vcf genotype fields can be accessed individually using array notation.
				<br>
				<ul>
					<li> <b>Genotype fields</b> are accessed using an index (sample number) followed by a variable name. E.g. If the genotypes are "GT:PL:GQ    1/1:255,66,0:63    0/1:245,0,255:99"
						You can write something like
						<pre>"( GEN[0].GQ > 60 ) & ( GEN[1].GQ > 90 )" </pre>

						You may use an asterisk to represent 'ANY' field
						<pre>"( GEN[*].GQ > 60 )" </pre>

					<li> <b>Genotype multiple fields</b> are accessed using an index (sample number) followed by a variable name and then another index. E.g. If the genotypes are "GT:PL:GQ    1/1:255,66,0:63    0/1:245,0,255:99"
						You can write something like
						<pre>"( GEN[0].PL[2] = 0 )" </pre>

						You may use an asterisk to represent 'ANY' field
						<pre>"( GEN[0].PL[*] = 0 )" </pre>

						...or even 
						<pre>"( GEN[*].PL[*] = 0 )" </pre>
				</ul>
				<br>
				<br>
				<i class="icon-hand-right"></i> You can create an expression using sample names instead of genotype numbers. 
				<br>
				E.g.
<pre>
$ java -jar SnpSift.jar filter "( GEN[HG00096].DS > 0.2 ) & ( GEN[HG00097].DS > 0.5 )" examples/1kg.head_chr1.vcf.gz 
</pre>
				<br>
				<br>


				<h3> Sets </h3>
					Sets are defined by the '-s' (or '--set') command line option. Each file must have one string per line. They are named based on the order used in the command line (e.g. the first one is 'SET[0]', the second one is 'SET[1]', etc.)
					<br>
					<br>
					Example: You can write something like (assuming your command line was "-s set1.txt -s set2.txt -s set3.txt"):
						<pre>"( ID in SET[2] )" </pre>

				<h3> SnpEff 'ANN' fields </h3>
				SnpEff annotations are parsed, so you can access individual sub-fields:
				<br>
				Effect fields (from SnpEff) are accessed using an index (effect number) followed by a sub-field name. 
				<br>
				Available <code>ANN</code> sub-fields are (for details, take a look at the <a href="VCFannotationformat_v1.0.pdf">specification</a>):
				<ul>
					<li> ALLELE (alias GENOTYPE)
					<li> EFFECT (alias ANNOTATION): Effect in Sequence ontology terms (e.g. 'missense_variant', 'synonymous_variant', 'stop_gained', etc.) 
					<li> IMPACT: { HIGH, MODERATE, LOW, MODIFIER }
					<li> GENE: Gene name (e.g. 'PSD3')
					<li> GENEID: Gene ID
					<li> FEATURE
					<li> FEATUREID (alias TRID: Transcript ID)
					<li> BIOTYPE: Biotype, as described by the annotations (e.g. 'protein_coding')
					<li> RANK: Exon or Intron rank (i.e. exon number in a transcript)
					<li> HGVS_C (alias HGVS_DNA, CODON): Variant in HGVS (DNA) notation
					<li> HGVS_P (alias HGVS, HGVS_PROT, AA): Variant in HGVS (protein) notation
					<li> CDNA_POS (alias POS_CDNA) 
					<li> CDNA_LEN (alias LEN_CDNA) 
					<li> CDS_POS (alias POS_CDS) 
					<li> CDS_LEN (alias LEN_CDS) 
					<li> AA_POS (alias POS_AA) 
					<li> AA_LEN (alias LEN_AA) 
					<li> DISTANCE
					<li> ERRORS (alias WARNING, INFOS)
				</ul>

				For example, you may want only the lines where the <b>first</b> annotation has <code>missense_variant</code> variant:
				<br>
				<br>
				<b>Important</b> According to the specification, there can be more than one EFFECT separated by &amp; (e.g. 'missense_variant&amp;splice_region_variant', thus using <code>has</code> operator is better than using equality operator (<code>=</code>). 
				For instance <code>'missense_variant&amp;splice_region_variant' = 'missense_variant'</code> is false, whereas  <code>'missense_variant&amp;splice_region_variant' has 'missense_variant'</code> is true.
				<br>

<pre>
$ java -jar SnpSift.jar filter "ANN[0].EFFECT has 'missense_variant'" examples/test.chr22.ann.vcf > test.chr22.ann.filter_missense_first.vcf

# Output example (edited for readibility)
$ cat test.chr22.ann.filter_missense_first.vcf
22    17072035    .    C    T    .    .    ANN=T|missense_variant|MODERATE|CCT8L2|ENSG00000198445|transcript|ENST00000359963|protein_coding|1/1|c.1406G>A|p.Gly469Glu|1666/2034|1406/1674|469/557||,T|downstream_gene_variant|MODIFIER|FABP5P11|ENSG00000240122|transcript|ENST00000430910|processed_pseudogene||n.*397G>A|||||3944|
22    17072258    .    C    A    .    .    ANN=A|missense_variant|MODERATE|CCT8L2|ENSG00000198445|transcript|ENST00000359963|protein_coding|1/1|c.1183G>T|p.Gly395Cys|1443/2034|1183/1674|395/557||,A|downstream_gene_variant|MODIFIER|FABP5P11|ENSG00000240122|transcript|ENST00000430910|processed_pseudogene||n.*397G>T|||||3721|
22    17072674    .    G    A    .    .    ANN=A|missense_variant|MODERATE|CCT8L2|ENSG00000198445|transcript|ENST00000359963|protein_coding|1/1|c.767C>T|p.Pro256Leu|1027/2034|767/1674|256/557||,A|downstream_gene_variant|MODIFIER|FABP5P11|ENSG00000240122|transcript|ENST00000430910|processed_pseudogene||n.*397C>T|||||3305|
22    17072747    .    T    C    .    .    ANN=C|missense_variant|MODERATE|CCT8L2|ENSG00000198445|transcript|ENST00000359963|protein_coding|1/1|c.694A>G|p.Met232Val|954/2034|694/1674|232/557||,C|downstream_gene_variant|MODIFIER|FABP5P11|ENSG00000240122|transcript|ENST00000430910|processed_pseudogene||n.*397A>G|||||3232|
22    17073043    .    C    T    .    .    ANN=T|missense_variant|MODERATE|CCT8L2|ENSG00000198445|transcript|ENST00000359963|protein_coding|1/1|c.398G>A|p.Arg133Gln|658/2034|398/1674|133/557||,T|downstream_gene_variant|MODIFIER|FABP5P11|ENSG00000240122|transcript|ENST00000430910|processed_pseudogene||n.*397G>A|||||2936|
22    17073119    .    C    T    .    .    ANN=T|missense_variant|MODERATE|CCT8L2|ENSG00000198445|transcript|ENST00000359963|protein_coding|1/1|c.322G>A|p.Val108Met|582/2034|322/1674|108/557||,T|downstream_gene_variant|MODIFIER|FABP5P11|ENSG00000240122|transcript|ENST00000430910|processed_pseudogene||n.*397G>A|||||2860|
</pre>

				...but this probably doesn't make much sense. What you may really want are lines where <b>ANY</b> effect to be <code>missense_variant</code>:
<pre>
$ java -jar SnpSift.jar filter "ANN[*].EFFECT has 'missense_variant'" examples/test.chr22.ann.vcf > test.chr22.ann.filter_missense_any.vcf

# Output example (edited for readibility)
$ cat test.chr22.ann.filter_missense_any.vcf
...
22    24891462    .    G    A    .    .    ANN=A|stop_gained|HIGH|UPB1|ENSG00000100024|transcript|ENST00000413389|protein_coding|2/10|c.59G>A|p.Trp20*|1652/3418|59/951|20/316||
                                              ,A|missense_variant|MODERATE|UPB1|ENSG00000100024|transcript|ENST00000326010|protein_coding|1/10|c.91G>A|p.Gly31Ser|435/2290|91/1155|31/384||
                                              ,A|missense_variant|MODERATE|UPB1|ENSG00000100024|transcript|ENST00000382760|protein_coding|1/4|c.91G>A|p.Gly31Ser|253/1928|91/561|31/186||

22    24896158    .    A    T    .    .    ANN=T|missense_variant|MODERATE|UPB1|ENSG00000100024|transcript|ENST00000326010|protein_coding|2/10|c.188A>T|p.Glu63Val|532/2290|188/1155|63/384||
                                              ,T|missense_variant|MODERATE|UPB1|ENSG00000100024|transcript|ENST00000382760|protein_coding|2/4|c.188A>T|p.Glu63Val|350/1928|188/561|63/186||
</pre>

				May be you want only the ones that affect <b>gene 'TRMT2A'</b>
<pre>
$ java -jar SnpSift.jar filter "(ANN[*].EFFECT has 'missense_variant') && (ANN[*].GENE = 'TRMT2A')" examples/test.chr22.ann.vcf > test.chr22.ann.filter_missense_any_TRMT2A.vcf

$ cat test.chr22.ann.filter_missense_any_TRMT2A.vcf
22    20103915    .    C    T    .    .    ANN=T|stop_gained|HIGH|RANBP1|ENSG00000099901|transcript|ENST00000432879|protein_coding|1/3|c.208C>T|p.Arg70*|455/744|208/497|70/164||WARNING_TRANSCRIPT_INCOMPLETE
                                              ,T|missense_variant|MODERATE|TRMT2A|ENSG00000099899|transcript|ENST00000439169|protein_coding|2/12|c.245G>A|p.Arg82His|561/2473|245/1932|82/643||
                                              ,T|missense_variant|MODERATE|TRMT2A|ENSG00000099899|transcript|ENST00000252136|protein_coding|2/12|c.245G>A|p.Arg82His|634/2964|245/1878|82/625||
                                              ,T|missense_variant|MODERATE|TRMT2A|ENSG00000099899|transcript|ENST00000403707|protein_coding|3/13|c.245G>A|p.Arg82His|607/2928|245/1878|82/625||
                                              ,T|missense_variant|MODERATE|TRMT2A|ENSG00000099899|transcript|ENST00000404751|protein_coding|2/12|c.245G>A|p.Arg82His|584/2498|245/1689|82/562||
                                              ,T|missense_variant|MODERATE|TRMT2A|ENSG00000099899|transcript|ENST00000445045|protein_coding|2/2|c.209G>A|p.Arg70His|432/582|209/359|70/118||WARNING_TRANSCRIPT_INCOMPLETE
                                              ,...

22    20103925    .    T    C    .    .    ANN=C|missense_variant|MODERATE|TRMT2A|ENSG00000099899|transcript|ENST00000439169|protein_coding|2/12|c.235A>G|p.Asn79Asp|551/2473|235/1932|79/643||
                                              ,C|missense_variant|MODERATE|TRMT2A|ENSG00000099899|transcript|ENST00000252136|protein_coding|2/12|c.235A>G|p.Asn79Asp|624/2964|235/1878|79/625||
                                              ,C|missense_variant|MODERATE|TRMT2A|ENSG00000099899|transcript|ENST00000403707|protein_coding|3/13|c.235A>G|p.Asn79Asp|597/2928|235/1878|79/625||
                                              ,C|missense_variant|MODERATE|TRMT2A|ENSG00000099899|transcript|ENST00000404751|protein_coding|2/12|c.235A>G|p.Asn79Asp|574/2498|235/1689|79/562||
                                              ,C|missense_variant|MODERATE|RANBP1|ENSG00000099901|transcript|ENST00000432879|protein_coding|1/3|c.218T>C|p.Phe73Ser|465/744|218/497|73/164||WARNING_TRANSCRIPT_INCOMPLETE
                                              ,C|missense_variant|MODERATE|TRMT2A|ENSG00000099899|transcript|ENST00000445045|protein_coding|2/2|c.199A>G|p.Asn67Asp|422/582|199/359|67/118||WARNING_TRANSCRIPT_INCOMPLETE
                                              ,C|splice_region_variant&intron_variant|LOW|RANBP1|ENSG00000099901|transcript|ENST00000430524|protein_coding|1/5|c.-374+7T>C||||||
                                              ,...
</pre>

				<h3> SnpEff 'EFF' fields </h3>
				<b>WARNING</b>: This section documents older SnpEff/SnpSift which used 'EFF' INFO field (as opposed to 'ANN' field) or files annotated using SnpEff's <code>-classic</code> or <code>-formatEff</code> command line options.
				</br>
				</br>
				SnpEff annotations are parsed, so you can access individual sub-fields:
				<br>
				Effect fields (from SnpEff) are accessed using an index (effect number) followed by a sub-field name. 
				<br>
				Available <code>EFF</code> sub-fields are:  
				<ul>
					<li> EFFECT: Effect (e.g. SYNONYMOUS_CODING, NON_SYNONYMOUS_CODING, FRAME_SHIFT, etc.)
					<li> IMPACT: { HIGH, MODERATE, LOW, MODIFIER }
					<li> FUNCLASS: { NONE, SILENT, MISSENSE, NONSENSE }
					<li> CODON: Codon change (e.g. 'ggT/ggG')
					<li> AA: Amino acid change (e.g. 'G156')
					<li> GENE: Gene name (e.g. 'PSD3')
					<li> BIOTYPE: Gene biotype, as described by the annotations (e.g. 'protein_coding')
					<li> CODING: Gene is { CODING, NON_CODING } 
					<li> TRID: Transcript ID
					<li> RANK: Exon or Intron rank (i.e. exon number in a transcript)
				</ul>

				For example, you may want only the lines where the first effect is a NON_SYNONYMOUS variants:
				<pre>"( EFF[0].EFFECT = 'NON_SYNONYMOUS_CODING' )" </pre>

				...but this probably doesn't make much sense. What you may really want are lines where ANY effect is NON_SYNONYMOUS:
				<pre>"( EFF[*].EFFECT = 'NON_SYNONYMOUS_CODING' )" </pre>

				May be you want only the ones that affect gene 'TCF7L2'
				<pre>"( EFF[*].EFFECT = 'NON_SYNONYMOUS_CODING' ) &  ( EFF[*].GENE = 'TCF7L2' )" </pre>

				<h3> SnpEff 'LOF' and 'NMD' fields </h3>
				Similarly <code>LOF</code> and <code>NMD</code> sub-fields are available:
				<ul>
					<li> LOF.GENE and NMD.GENE
					<li> LOF.GENEID and NMD.GENEID
					<li> LOF.NUMTR and NMD.NUMTR
					<li> LOF.PERC and NMD.PERC
				</ul>

				For instance, if we want to obtain genes having a Loss of Function effect in more than 90% of the transcripts, you can do this:
<pre>
$cat test.snpeff.vcf | java -Xmx1G -jar SnpSift.jar filter "(exists LOF[*].PERC) & (LOF[*].PERC > 0.9)" 
</pre>
				<i class="icon-warning-sign"></i> We assume that 'test.snpeff.vcf' was annotated with SnpEff using '-lof' command line option.

				
				<h3> Available operands and functions </h3>
				<p>
				The following operators and functions are interpreted by <code>SnpSift filter</code>:
				</p>
				<center>
				<table class="table table-striped">
					<tr> <th> Operand </th> <th> Description </th> <th> Data type </th> <th> Example </th> </tr>
					<tr> 
						<td> = </td> 
						<td> Equality test </td> 
						<td> FLOAT, INT or STRING </td> 
						<td style="white-space: nowrap"> (REF <b>=</b> 'A') </td> 
					</tr>
					<tr> 
						<td> &gt; </td> 
						<td> Greater than </td> 
						<td> FLOAT or INT </td>
						<td style="white-space: nowrap"> (DP <b>&gt;</b> 20) </td> 
					</tr>
					<tr> 
						<td> &ge; </td> 
						<td> Greater or equal than </td> 
						<td> FLOAT or INT </td>
						<td style="white-space: nowrap"> (DP <b>&ge;</b> 20) </td> 
					</tr>
					<tr> 
						<td> &lt; </td> 
						<td> Less than </td> 
						<td> FLOAT or INT </td>
						<td style="white-space: nowrap"> (DP <b>&lt;</b> 20) </td> 
					</tr>
					<tr> 
						<td> &le; </td> 
						<td> Less or equal than </td> 
						<td> FLOAT or INT </td>
						<td style="white-space: nowrap"> (DP <b>&le;</b> 20) </td> 
					</tr>
					<tr> 
						<td> =~ </td> 
						<td> Match regular expression </td> 
						<td> STRING </td>
						<td style="white-space: nowrap"> (REL <b>=~</b> 'AC') </td> 
					</tr>
					<tr> 
						<td> !~ </td> 
						<td> Does not match regular expression </td> 
						<td> STRING </td>
						<td style="white-space: nowrap"> (REL <b>!~</b> 'AC') </td> 
					</tr>
					<tr> 
						<td> &amp; </td> 
						<td> AND operator  </td> 
						<td> Boolean </td>
						<td style="white-space: nowrap"> (DP &gt 20) <b>&amp;</b> (REF = 'A') </td> 
					</tr>
					<tr> 
						<td> | </td> 
						<td> OR operator  </td> 
						<td> Boolean </td>
						<td style="white-space: nowrap"> (DP &gt 20) <b>|</b> (REF = 'A') </td> 
					</tr>
					<tr> 
						<td> ! </td> 
						<td> NOT operator  </td> 
						<td> Boolean </td>
						<td style="white-space: nowrap"> <b>!</b> (DP &gt 20) </td>
					</tr>
					<tr> 
						<td> exists </td> 
						<td> The variable exists (not missing)</td> 
						<td> Any </td>
						<td style="white-space: nowrap"> (<b>exists</b> INDEL) </td>
					</tr>
					<tr> 
						<td> has </td> 
						<td> The right hand side expression is equalt to any of the items in a list consisting of separating the left hand side expression using delimiters: '&amp;', '+', ';', ',', ':', '(', ')' ,'[', ']'<p> 
							 Example: If the expression is: ANN[*].EFFECT <b>has</b> 'missense_variant'<br>
							 If left hand side (ANN[*].EFFECT) has value 'missense_variant&splice_region_variant', then it is transformed to a list: ['missense_variant', 'splice_region_variant']<br>
							 Since the right hand side ('missense_variant') is in the list, the expression evaulates to 'true'
						</td> 
						<td> Any </td>
						<td style="white-space: nowrap"> (ANN[*].EFFECT <b>has</b> 'missense_variant') </td>
					</tr>
					<tr> <th> Function </th> <th> Description </th> <th> Data type </th> <th> Example </th> </tr>
					<tr> 
						<td> countHom() </td> 
						<td> Count number of homozygous genotypes</td> 
						<td> No arguments </td>
						<td style="white-space: nowrap"> (<b>countHom()</b> &gt 0) </td>
					</tr>
					<tr> 
						<td> countHet() </td> 
						<td> Count number of heterozygous genotypes</td> 
						<td> No arguments </td>
						<td style="white-space: nowrap"> (<b>countHet()</b> &gt 2) </td>
					</tr>
					<tr> 
						<td> countVariant() </td> 
						<td> Count number of genotypes that are variants (i.e. not reference 0/0)</td> 
						<td> No arguments </td>
						<td style="white-space: nowrap"> (<b>countVariant()</b> &gt 5) </td>
					</tr>
					<tr> 
						<td> countRef() </td> 
						<td> Count number of genotypes that are NOT variants (i.e. reference 0/0)</td> 
						<td> No arguments </td>
						<td style="white-space: nowrap"> (<b>countRef()</b> &lt 1) </td>
					</tr>
					<tr> <th> Genotype <br> Function </th> <th> Description </th> <th> Data type </th> <th> Example </th> </tr>
					<tr> 
						<td> isHom </td> 
						<td> Is homozygous genotype?</td> 
						<td> Genotype </td>
						<td style="white-space: nowrap"> <b>isHom( GEN[0] )</b> </td>
					</tr>
					<tr> 
						<td> isHet </td> 
						<td> Is heterozygous genotype?</td> 
						<td> Genotype </td>
						<td style="white-space: nowrap"> <b>isHet( GEN[0] )</b> </td>
					</tr>
					<tr> 
						<td> isVariant </td> 
						<td> Is genotype a variant? (i.e. not reference 0/0)</td> 
						<td> Genotype </td>
						<td style="white-space: nowrap"> <b>isVariant( GEN[0] )</b> </td>
					</tr>
					<tr> 
						<td> isRef </td> 
						<td> Is genotype a reference? (i.e. 0/0)</td> 
						<td> Genotype </td>
						<td style="white-space: nowrap"> <b>isRef( GEN[0] )</b> </td>
					</tr>
				</table>
				</center>
				<br>
				<h3> Using sample names instead of sample numbers </h3>
				As of version 4.1A, SnpSift allows to use sample names instead of sample numbers.
				This allows to create more readable expressions.
				<br>
				<br>
				Example:

<pre>
$ cat cancer.vcf | java -jar SnpSift.jar filter "GEN[Somatic].GT = '2/1'"
#CHROM  POS    ID   REF  ALT    QUAL  FILTER    INFO    FORMAT    Germline    Somatic
1       69091  .    A    C,G    .     PASS      AC=1    GT        1/0         2/1
</pre>

				Note that we used <code>GEN[Somatic]</code> instead of <code>GEN[1]</code>. 
				<br>
				<br>

        </section>

        <!-- Annotate
        ================================================== -->
        <section id="annotate">
          <div class="page-header">
            <h1>3. SnpSift Annotate</h1>
          </div>
				<p class="lead">
				Annotate using fields from another VCF file (e.g. dbSnp, 1000 Genomes projects, ClinVar, ExAC, etc.).
				</p>

				This is typically used to annotate IDs and INFO fields from a 'database' VCF file (e.g. dbSnp). 
				Here is an example:
				<pre> java -jar SnpSift.jar annotate dbSnp132.vcf variants.vcf > variants_annotated.vcf </pre>
				<p>
				Important: <code>SnpSift annotate</code> command has different strategies depending on the input VCF file:
				<ul>
					<li> <b>Uncomressed VCF</b> If the file is not compressed, it created an index in memory to optimize search. This assumes that both the database and the input VCF files are sorted by position, since it is required by the VCF standard (chromosome sort order can differ between files).
					<li> <b> Compressed, Tabix indexed</b> It uses the tabix index to speed up annotations.
					<li> <b> Compressed, NOT Tabix indexed</b> It loads the entire 'database' VCF file into memory, which may be slow or even impractical for large 'database' VCF files.  This allows to annotate using unsorted VCF files. 
				<p>
				Note:
					<ul>
						<li> By default it adds ALL database INFO fields. 
						<li> You can use the <code>-info</code> command line option if you only want select only a subset of fields from db.vcf file.
						<li> You can use the <code>-id</code> command line option if you only want to add ID fields (no INFO fields will be added).
						<li> Using the <code>-exists</code> command line option, you can annotate entries that exists in the 'database' file.
					</ul>
				<br>
				<i class="icon-hand-right"></i> DbSnp in VCF format can be downloaded 
					<a href="ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606/VCF/00-All.vcf.gz"> here (GRCh38 coordinates) </a>.
					For other versions, check <a href="ftp://ftp.ncbi.nih.gov/snp/organisms/"> this link</a>.
					<p>
				<br>
				<br>
				<b>Example 1</b>: Annotating <code>ID</code> from dbSnp:
				<br>
<pre>
$ cat test.chr22.vcf
#CHROM  POS         ID           REF  ALT  QUAL   FILTER  INFO
22      16157571    .            T    G    0.0    FAIL    NS=53
22      16346045    .            T    C    0.0    FAIL    NS=244
22      16350245    .            C    A    0.0    FAIL    NS=192
22      17054103    .            G    A    0.0    PASS    NS=404
22      17071906    .            A    T    0.0    PASS    NS=464
22      17072347    .            C    T    0.0    PASS    NS=464
22      17072394    .            C    G    0.0    PASS    NS=463
22      17072411    .            G    T    0.0    PASS    NS=464

$ java -jar SnpSift.jar annotate -id db/dbSnp/dbSnp137.20120616.vcf test.chr22.vcf 
#CHROM  POS         ID           REF  ALT  QUAL   FILTER  INFO
22      16157571    .            T    G    0.0    FAIL    NS=53
22      16346045    rs56234788   T    C    0.0    FAIL    NS=244
22      16350245    rs2905295    C    A    0.0    FAIL    NS=192
22      17054103    rs4008588    G    A    0.0    PASS    NS=404
22      17071906    .            A    T    0.0    PASS    NS=464
22      17072347    rs139948519  C    T    0.0    PASS    NS=464
22      17072394    .            C    G    0.0    PASS    NS=463
22      17072411    rs41277596   G    T    0.0    PASS    NS=464
</pre>

				<b>Example 2</b>: Annotatating <code>ID</code> and all <code>INFO</code> fields from dbSnp (VCF headers not shown for brevity):
<pre>
$ cat test.chr22.vcf
#CHROM  POS         ID           REF  ALT  QUAL   FILTER  INFO
22      16157571    .            T    G    0.0    FAIL    NS=53
22      16346045    .            T    C    0.0    FAIL    NS=244
22      16350245    .            C    A    0.0    FAIL    NS=192
22      17054103    .            G    A    0.0    PASS    NS=404
22      17071906    .            A    T    0.0    PASS    NS=464
22      17072347    .            C    T    0.0    PASS    NS=464
22      17072394    .            C    G    0.0    PASS    NS=463
22      17072411    .            G    T    0.0    PASS    NS=464

$ java -jar SnpSift.jar annotate db/dbSnp/dbSnp137.20120616.vcf test.chr22.vcf 
#CHROM  POS         ID           REF  ALT  QUAL   FILTER  INFO
22      16157571    .            T    G    0.0    FAIL    NS=53
22      16346045    rs56234788   T    C    0.0    FAIL    NS=244;RSPOS=16346045;GMAF=0.162248628884826;dbSNPBuildID=129;SSR=0;SAO=0;VP=050100000000000100000100;WGT=0;VC=SNV;SLO;GNO
22      16350245    rs2905295    C    A    0.0    FAIL    NS=192;RSPOS=16350245;GMAF=0.230804387568556;dbSNPBuildID=101;SSR=1;SAO=0;VP=050000000000000100000140;WGT=0;VC=SNV;GNO
22      17054103    rs4008588    G    A    0.0    PASS    NS=404;RSPOS=17054103;GMAF=0.123400365630713;dbSNPBuildID=108;SSR=0;SAO=0;VP=050100000000070010000100;WGT=0;VC=SNV;SLO;VLD;G5A;G5;KGPilot123
22      17071906    .            A    T    0.0    PASS    NS=464
22      17072347    rs139948519  C    T    0.0    PASS    NS=464;RSPOS=17072347;dbSNPBuildID=134;SSR=0;SAO=0;VP=050200000004040010000100;WGT=0;VC=SNV;S3D;ASP;VLD;KGPilot123
22      17072394    .            C    G    0.0    PASS    NS=463
22      17072411    rs41277596   G    T    0.0    PASS    NS=464;RSPOS=17072411;GMAF=0.00411334552102377;dbSNPBuildID=127;SSR=0;SAO=0;VP=050200000008040010000100;GENEINFO=CCT8L2:150160;WGT=0;VC=SNV;S3D;CFL;VLD;KGPilot123
</pre>
        </section>

        <!-- CaseControl
        ================================================== -->
        <section id="casecontrol">
          <div class="page-header">
            <h1>4. SnpSift CaseControl </h1>
          </div>
				<p class="lead">
				Allows you to count how many samples are in 'case' and 'control' groups. 
				</p>

				<p>
				This command counts the number of 'homozygous', 'heterozygous' and 'total' variants in a case and control groups and performs some basic pValue calculation using Fisher exact test and Cochran-Armitage test.
				
				<br>
				<br>
				Case and Control groups can be defined either by a command line string or a TFAM file (see <a href="http://pngu.mgh.harvard.edu/~purcell/plink/data.shtml#tr">PLINK's documentation</a>).
				<br>
				Case/Control command line string containing plus and minus symbols {'+', '-', '0'} where '+' is case, '-' is control and '0' is neutral (ignored).
				<br>
				E.g. We have ten samples, which means ten genotype columns in the VCF file. 
				The first four are 'cases', the fifth one is 'neutral', and the last five are 'control'. 
				So the description string would be "++++0-----" (note that the following output has been edited, only counts are shown, no pValues):
<pre>
$ java -jar SnpSift.jar caseControl "++++0-----" cc.vcf 
#CHROM  POS    ID  REF  ALT  QUAL  FILTER  INFO                                FORMAT  Sample_01  Sample_02  Sample_03  Sample_04  Sample_05  Sample_06  Sample_07  Sample_08  Sample_09  Sample_10
1       69496  .   G    A    .     PASS    AF=0.01;Cases=1,2,4;Controls=2,2,6  GT      0/1        1/1        1/0        0/0        0/0        0/1        1/1        1/1        1/0        0/0
</pre>
				Cases genotypes are samples 1 to 4 : 0/1, 1/1, 1/0 and 0/0. So there are 1 homozygous, 2 heterozygous, and a total of 4 variants (2 * 1 + 1 * 2 = 4).
				Thus the annotation is <code>Cases=1,2,4</code>
				<br>
				Control genotypes are samples 6 to 10 : 0/1, 1/1, 1/1, 1/0 and 0/0. So there are 2 homozygous, 2 heterozygous, and a total of 6 variants (2 * 2 + 1 * 2 = 6)
				Thus the annotation is <code>Controls=2,2,6</code>
				<br>
				<br>
				<i class="icon-hand-right"></i> You can use the <code>-tfam</code> command line option to specify a TFAM file.
				Case, control from are read from phenotype field of a TFAM file (6th column). 
				Phenotype order in TFAM files do not need to match VCF sample order (sample IDs are used).
				Phenotype column should be coded as {0,1,2} meaning {Missing, Control, Case} respectively.
				See <a href="http://pngu.mgh.harvard.edu/~purcell/plink/data.shtml">PLINK's reference</a> for details about TFAM file format.
				<br>
				<br>
				<i class="icon-hand-right"></i> You can use the <code>-name nameString</code> command line option to add name to the INFO tags. 
				This can be used to count different case/control groups in the same dataset (e.g. multiple phenotypes)
<pre>
$  java -jar SnpSift.jar caseControl -name "_MY_GROUP" "++++0-----" cc.vcf \
	| java -jar SnpSift.jar caseControl -name "_ANOTHER_GROUP" "+-+-+-+-+-" -

#CHROM  POS    ID  REF  ALT  QUAL  FILTER  INFO                                                                                                         FORMAT  Sample_01  Sample_02  Sample_03  Sample_04  Sample_05  Sample_06  Sample_07  Sample_08  Sample_09  Sample_10
1       69496  .   G    A    .     PASS    AF=0.01;Cases_MY_GROUP=1,2,4;Controls_MY_GROUP=2,2,6;Cases_ANOTHER_GROUP=1,3,5;Controls_ANOTHER_GROUP=2,1,5  GT      0/1        1/1        1/0        0/0        0/0        0/1        1/1        1/1        1/0        0/0
</pre>

				<h3> p-values </h3>
				SnpSift caseControl calculates the p-value using different models: dominant, recessive, allelic and co-dominant.
				
				<br>
				<br>
				<i class="icon-hand-right"></i> When we say we use Fisher exact test, it means that we use the real Fisher exact test calculation, not approximations (like Chi-Square approximations). 
				So the p-values should be correct even for low counts on any of the values in the contingency tables.
				Approximations tend to be wrong when any count in a contingency table is below 5.
				You should not see that problem here.
				<br>
				<br>
				
				Models:
				<ul>
					<li> Dominant model (<code>CC_DOM</code>): A 2 by 2 contingency table is created
					<table class="table table-striped">
						<tr> <th> </th>    <th> Alt (A/a + a/a) </th>  <th> Ref (A/A)</th> </tr>
						<tr> <th> Cases    </th> <td> N11</td>         <td> N12 </td> </tr>
						<tr> <th> Controls </th> <td> N21</td>         <td> N22 </td> </tr>
					</table>
					This means that the first column are the number of samples that have ANY non-reference: either 1 (heterozygous) or 2 (homozygous).
					Fisher exact test is used to calculate the p-value.
					<br>
					<br>
					<li> Recessive model (<code>CC_REC</code>): A 2 by 2 contingency table is created
					<table class="table table-striped">
						<tr> <th> </th>    <th> Alt (a/a) </th>  <th> Ref + Het (A/A + A/a)</th> </tr>
						<tr> <th> Cases    </th> <td> N11</td>         <td> N12 </td> </tr>
						<tr> <th> Controls </th> <td> N21</td>         <td> N22 </td> </tr>
					</table>
					This means that the first column are the number of samples that have both non-reference chromosomes: homozygous ALT.
					Fisher exact test is used to calculate the p-value.
					<br>
					<br>
					<li> Allelic model (<code>CC_ALL</code>): A 2 by 2 contingency table is created
					<table class="table table-striped">
						<tr> <th> </th>    <th> Variants </th>  <th> References </th> </tr>
						<tr> <th> Cases    </th> <td> N11</td>         <td> N12 </td> </tr>
						<tr> <th> Controls </th> <td> N21</td>         <td> N22 </td> </tr>
					</table>
					This means that the first column are the number of non-reference genotypes. 
					For instance homozygous reference samples count as 0, heterozygous count as 1 and homozygous non-reference count as 2.
					Fisher exact test is used to calculate the p-value.
					<br>
					<br>
					<li> Genotipic / Codominant model (<code>CC_GENO</code>): A 2 by 3 contingency table is created
					<table class="table table-striped">
						<tr> <th> </th>          <th> A/A </th>  <th> a/A </th>  <th> a/a </th> </tr>
						<tr> <th> Cases    </th> <td> N11 </td>  <td> N12 </td>  <td> N13 </td> </tr>
						<tr> <th> Controls </th> <td> N21 </td>  <td> N22 </td>  <td> N23 </td> </tr>
						<tr> <th> Weight   </th> <td> 0.0 </td>  <td> 1.0 </td>  <td> 2.0 </td> </tr>
					</table>
					This means that the first column are the number of homozygous reference genotypes.
					The second column is the number of heterozygous.
					And the third column is the number of homozygous non-reference. 
					Cochran-Armitage test is used to calculate the p-value, using the weights shown in the last row.
				</ul>


        </section>


        <!-- Intervals
        ================================================== -->
        <section id="Intervals">
          <div class="page-header">
            <h1>5. SnpSift Intervals </h1>
          </div>
				<p class="lead">
				This is used to extract variants that intersect any interval. 
				</p>

				<p>
				You must provide intervals as BED files.
				<br>
				Command line options: <br>
				<ul>
					<li> '-x' : Filter out (exclude) VCF entries that match any interval in the BED files.
					<li> '-i file.vcf' : Specify the input VCF file (default is STDIN).
				</ul>

				<p>
				E.g.: 
				<pre> cat variants.vcf | java -jar SnpSift.jar intervals my_intervals.bed > variants_intersecting_intervals.vcf </pre>
				<br>
				<br>
				<i class="icon-warning-sign"></i>  BED file format is tab separated zero-based coordinates "chr \t start \t end " (for this application, all other fields in the BED file are ignored).<br>
				<br>
				<i class="icon-warning-sign"></i>  If BED file has header lines, they must start with a '#' 
				<br>
        </section>
	
        <!-- intidx
        ================================================== -->
        <section id="intidx">
          <div class="page-header">
            <h1>6. SnpSift Intervals Index </h1>
          </div>
				<p class="lead">
				This is used to extract variants that intersect any interval. 
				</p>
				<p>
				<i class="icon-warning-sign"></i>  This is similar to "SnpSift intervals", but intended for huge VCF files, and relatively small number of intervals.
				<br>
				<br>
				This command indexes the VCF file, thus is optimized for huge VCF files.
				You must provide intervals as BED files.
				BED format is tab separated zero-based coordinates "chr \t start \t end " (for this application, all other fields in the BED file are ignored).
				You can use command line option '-if 1' if you want one-based coordinates.
				<br>
				<br>
				E.g.: 
				<pre> java -jar SnpSift.jar intidx variants.vcf my_intervals.bed > variants_intersecting_intervals.vcf </pre>

				You can also have genomic coordinate in the command line.
				Note that in this case, coordinates are assumed to be one-based (instead of zero-based, like in BED files):
				<pre> java -jar SnpSift.jar intidx -c variants.vcf chr1:12345-23456 chr2:3456789-4567890  > variants_intersecting_intervals.vcf </pre>
				<br>
				<br>
				<i class="icon-warning-sign"></i>  BED file format is tab separated zero-based coordinates "chr \t start \t end " (for this application, all other fields in the BED file are ignored).<br>
				<br>
				<i class="icon-warning-sign"></i>  If BED file has header lines, they must start with a '#' 
				<br>
        </section>

        <!-- Join
        ================================================== -->
        <section id="Join">
          <div class="page-header">
            <h1>7. SnpSift Join </h1>
          </div>
				<p class="lead">
				Join files by genomic regions (i.e. chr:start-end). 
				</p>
				Files can be generic TXT (tab separated), VCF or BED.<br>
				Usage example:
<pre>
Usage: java -jar SnpSift.jar join [options] file1 file2 
Note: It is assumed that both files fit in memory.
Options:
    -if1 &lt;num&gt;       : Offset for file1 (e.g. 1 if coordinates are one-based. Default: 1
    -if2 &lt;num&gt;       : Offset for file2 (e.g. 2 if coordinates are one-based. Default: 1
    -cols1 &lt;colDef&gt;  : Column definition for file 1. Format: chrCol,startCol,endCol (e.g. '1,2,3'). 
                       Shortcuts 'bed' or 'vcf' are allowed. Default: 'vcf
    -cols2 &lt;colDef&gt;  : Column definition for file 2. Format: chrCol,startCol,endCol (e.g. '1,2,3'). 
                       Shortcuts 'bed' or 'vcf' are allowed. Default: 'vcf
    -all             : For each interval, show all intersecting. 
                       Default: show only one (the largest intersection)
    -closest         : Show closest intervals in file2 if none intersect. 
                       Default: off
    -empty           : Show intervals in file1 even if they do not intersect with any other interval. 
                       Default: off
</pre>

Example: Join two bed files, showing intersecting or closest intervals
<pre>
java -Xmx2G -jar SnpSift.jar join -v -cols1 bed -cols2 bed -closest file1.bed file2.bed
</pre>

Example: Join one bed file and another file having chr:start-end in columns 7,8 and 9 respectively. Showing intervals form file1 that do not intersect any interval from file2
<pre>
java -Xmx2G -jar SnpSift.jar join -v -cols1 bed -cols2 7,8,9 -empty file.bed my_weird_file.txt
</pre>
        </section>

        <!-- RmRefGen
        ================================================== -->
        <section id="RmRefGen">
          <div class="page-header">
            <h1>8. SnpSift RmRefGen </h1>
          </div>
				<p class="lead">
				Remove reference genotypes. 
				</p>

				Replaces genotype information for non-variant samples. <p>
				E.g. If you have this file:
<pre>
#CHROM  POS     ID      REF     ALT     QUAL    FILTER  INFO    FORMAT       M1                 M2                X1              X2              
2L      426906  .       C       G       53.30   .       DP=169  GT:PL:GQ     0/1:7,0,255:4      0/1:7,0,255:4     0/0:0,0,0:6     0/0:0,30,255:35 
2L      601171  .       C       A       999.00  .       DP=154  GT:PL:GQ     0/1:81,0,141:78    0/1:42,0,251:39   0/0:0,0,0:4     0/0:0,33,255:36 
2L      648611  .       A       T       999.00  .       DP=225  GT:PL:GQ     0/1:52,0,42:47     1/1:75,21,0:14    0/0:0,0,0:3     0/0:0,60,255:61 
2L      807373  .       A       G       106.00  .       DP=349  GT:PL:GQ     0/1:14,0,65:12     0/1:60,0,42:50    0/0:0,0,0:4     0/0:0,69,255:72 
2L      816766  .       G       T       999.00  .       DP=411  GT:PL:GQ     0/1:108,0,45:53    0/1:7,0,255:6     0/0:0,0,0:4     0/0:0,57,255:59 
</pre>

You can run:
<pre> cat file.vcf | java -jar SnpSift.jar rmRefGen > file_noref.vcf </pre>

and you get this (notice the last two columns, that had '0/0' genotype):
<pre>
#CHROM  POS     ID      REF     ALT     QUAL    FILTER  INFO    FORMAT       M1                 M2                X1    X2              
2L      426906  .       C       G       53.30   .       DP=169  GT:PL:GQ     0/1:7,0,255:4      0/1:7,0,255:4     .     .
2L      601171  .       C       A       999.00  .       DP=154  GT:PL:GQ     0/1:81,0,141:78    0/1:42,0,251:39   .     .
2L      648611  .       A       T       999.00  .       DP=225  GT:PL:GQ     0/1:52,0,42:47     1/1:75,21,0:14    .     .
2L      807373  .       A       G       106.00  .       DP=349  GT:PL:GQ     0/1:14,0,65:12     0/1:60,0,42:50    .     .
2L      816766  .       G       T       999.00  .       DP=411  GT:PL:GQ     0/1:108,0,45:53    0/1:7,0,255:6     .     .
</pre>
        </section>

        <!-- TsTv
        ================================================== -->
        <section id="TsTv">
          <div class="page-header">
            <h1>9. SnpSift TsTv </h1>
          </div>
				<p class="lead">
				Calculate transition vs transversion ratios for each sample.
				</p>

				Usage example:
				<pre> 
$ java -jar SnpSift.jar tstv hom s.vcf 

Sample        :	1	2	3	4	5	6	7	8	9	10	11	12	Total
Transitions   :	150488	150464	158752	156674	152936	160356	152276	155314	156484	149276	151182	153468	1847670
Transversions :	70878	70358	73688	72434	70828	76150	72030	71958	72960	69348	70180	71688	862500
Ts/Tv         :	2.123	2.139	2.154	2.163	2.159	2.106	2.114	2.158	2.145	2.153	2.154	2.141	2.142	

</pre>
        </section>
			
        <!-- Extract
        ================================================== -->
        <section id="Extract">
          <div class="page-header">
            <h1>10. SnpSift Extract Fields </h1>
          </div>
				<p class="lead">
				Extract fields from a VCF file to a TXT, tab separated format, that you can easily load in R, XLS, etc.
				</p>
				You can also use sub-fields and genotype fields / sub-fields such as:
				<p>
				<ul>
					<li> Standard VCF fields: 
						<ul>
							<li> CHROM
							<li> POS
							<li> ID
							<li> REF
							<li> ALT
							<li> FILTER
						</ul>
					<li> INFO fields: 
						<ul>
							<li> AF
							<li> AC
							<li> DP
							<li> MQ
							<li> etc. (any info field available)
						</ul>
					<li> SnpEff 'ANN' fields: 
						<ul>
							<li> "ANN[*].ALLELE" (alias GENOTYPE)
							<li> "ANN[*].EFFECT" (alias ANNOTATION): Effect in Sequence ontology terms (e.g. 'missense_variant', 'synonymous_variant', 'stop_gained', etc.) 
							<li> "ANN[*].IMPACT:" { HIGH, MODERATE, LOW, MODIFIER }
							<li> "ANN[*].GENE:" Gene name (e.g. 'PSD3')
							<li> "ANN[*].GENEID:" Gene ID
							<li> "ANN[*].FEATURE
							<li>" ANN[*].FEATUREID (alias TRID: Transcript ID)
							<li> "ANN[*].BIOTYPE:" Biotype, as described by the annotations (e.g. 'protein_coding')
							<li> "ANN[*].RANK:" Exon or Intron rank (i.e. exon number in a transcript)
							<li> "ANN[*].HGVS_C" (alias HGVS_DNA, CODON): Variant in HGVS (DNA) notation
							<li> "ANN[*].HGVS_P" (alias HGVS, HGVS_PROT, AA): Variant in HGVS (protein) notation
							<li> "ANN[*].CDNA_POS" (alias POS_CDNA) 
							<li> "ANN[*].CDNA_LEN" (alias LEN_CDNA) 
							<li> "ANN[*].CDS_POS" (alias POS_CDS) 
							<li> "ANN[*].CDS_LEN" (alias LEN_CDS) 
							<li> "ANN[*].AA_POS" (alias POS_AA) 
							<li> "ANN[*].AA_LEN" (alias LEN_AA) 
							<li> "ANN[*].DISTANCE"
							<li> "ANN[*].ERRORS" (alias WARNING, INFOS)
						</ul>
					<li> SnpEff 'EFF' fields (this is for older SnpEff/SnpSift versions, new version use 'ANN' field): 
						<ul>
							<li> "EFF[*].EFFECT"
							<li> "EFF[*].IMPACT"
							<li> "EFF[*].FUNCLASS"
							<li> "EFF[*].CODON"
							<li> "EFF[*].AA"
							<li> "EFF[*].AA_LEN"
							<li> "EFF[*].GENE"
							<li> "EFF[*].BIOTYPE"
							<li> "EFF[*].CODING"
							<li> "EFF[*].TRID"
							<li> "EFF[*].RANK"
						</ul>
						<i class="icon-hand-right"></i> You can combine <code>vcfEffOnePerLine.pl</code> script with <code>SnpSift extractFields</code> if you want to have each effect in a seprarate line.
					<li> SnpEff 'LOF' fields: 
						<ul>
							<li> "LOF[*].GENE"
							<li> "LOF[*].GENEID"
							<li> "LOF[*].NUMTR"
							<li> "LOF[*].PERC"
						</ul>
					<li> SnpEff' NMD' fields: 
						<ul>
							<li> "NMD[*].GENE"
							<li> "NMD[*].GENEID"
							<li> "NMD[*].NUMTR"
							<li> "NMD[*].PERC"
						</ul>
				</ul>

				<br>
				<br>
				<i class="icon-warning-sign"></i>  When using multiple indexes (e.g. "ANN[*].EFFECT") you must remember to use quotes the command line. Otherwise, the shell would parse the asterisk changing the expression and producing unexpected results.
				<br>
				<br>
				<br>
				<i class="icon-hand-right"></i> You can use command line option <code>-s</code> to specify multiple field separator and <code>-e</code> to specify how to represent empty fields.
				<br>
				<br>
				<p>
				<b>Example 1:</b> Extracting chromosome, position, ID and allele frequency from a VCF file:
				<pre>
$ java -jar SnpSift.jar extractFields s.vcf CHROM POS ID AF | head
#CHROM        POS        ID            AF
1             69134                    0.086
1             69496      rs150690004   0.001
1             69511      rs75062661    0.983
1             69569                    0.538
1             721559                   0.001
1             721757                   0.011
1             846854     rs111957712   0.003
1             865584     rs148711625   0.001
1             865625     rs146327803   0.001
</pre>

				<p>
				<b>Example 2:</b> Extracting genotype fields
<pre>
$ java -jar SnpSift.jar extractFields file.vcf CHROM" "POS" "ID" "THETA" "GEN[0].GL[1]" "GEN[1].GL" "GEN[3].GL[*]" "GEN[*].GT"
</pre>

				This means to extract:
				<ul>
				  <li> CHROM POS ID: regular fields (as in the previous example)
				  <li> THETA : This one is from INFO
				  <li> GEN[0].GL[1] : Second likelihood from first genotype
				  <li> GEN[1].GL : The whole GL fiels (all entries without separating them)
				  <li> "GEN[3].GL[*]" : All likelihoods form genotype 3 (this time they will be tab separated, as opposed to the previous one).
				  <li> "GEN[*].GT" : Genotype subfields (GT) from ALL samples (tab separated).
				</ul>
				The result will look something like:
<pre>
#CHROM  POS     ID              THETA   GEN[0].GL[1]    GEN[1].GL               GEN[3].GL[*]            GEN[*].GT
1       10583   rs58108140      0.0046  -0.47           -0.24,-0.44,-1.16       -0.48   -0.48   -0.48   0|0     0|0     0|0     0|1     0|0     0|1     0|0     0|0     0|1 
1       10611   rs189107123     0.0077  -0.48           -0.24,-0.44,-1.16       -0.48   -0.48   -0.48   0|0     0|1     0|0     0|0     0|0     0|0     0|0     0|0     0|0 
1       13302   rs180734498     0.0048  -0.58           -2.45,-0.00,-5.00       -0.48   -0.48   -0.48   0|0     0|1     0|0     0|0     0|0     1|0     0|0     0|1     0|0 
1       13327   rs144762171     0.0204  -1.11           -1.97,-0.01,-2.51       -0.48   -0.48   -0.48   0|0     0|1     0|0     0|0     0|0     1|0     0|0     0|0     0|0 
1       13957   rs201747181     0.0100  0               0,0,0                   0       0       0       0|0     0|1     0|0     0|0     0|0     0|0     0|0     0|0     0|0 
1       13980   rs151276478     0.0139  -0.48           -0.48,-0.48,-0.48       -0.48   -0.48   -0.48   0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0 
1       30923   rs140337953     0.0162  -0.61           -0.10,-0.69,-2.81       -0.48   -0.48   -0.48   1|1     0|0     0|0     1|1     1|0     0|0     1|1     1|0     1|1 
1       46402   rs199681827     0.0121  0               0,0,0                   0       0       0       0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0 
1       47190   rs200430748     0.0153  0               0,0,0                   0       0       0       0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0     0|0 
</pre>

				<br>
				<br>
				<b>Example 3:</b> Extracting fields with multiple values in a friendlier format.
				You can use command line option <code>-s</code> to specify multiple field separator and <code>-e</code> to specify how to represent empty fields.
				<br>
<pre>
$ java -jar SnpSift.jar extractFields -s "," -e "." test.chr22.ann.vcf CHROM POS REF ALT "EFF[*].EFFECT" "EFF[*].AA" 
</pre>
				<br>
				Notice how we separate same fields using "," instead of the default tab using the option <code>-s ","</code>, and we use "." for empty fiels (option <code>-e "."</code>).
				The results is:
				<br>
<pre>
$ java -jar SnpSift.jar extractFields -s "," -e "." examples/test.chr22.ann.vcf CHROM POS REF ALT "ANN[*].EFFECT" "ANN[*].HGVS_P" 
#CHROM	POS	REF	ALT	ANN[*].EFFECT	ANN[*].HGVS_P
22	17071756	T	C	3_prime_UTR_variant,downstream_gene_variant	.,.
22	17072035	C	T	missense_variant,downstream_gene_variant	p.Gly469Glu,.
22	17072258	C	A	missense_variant,downstream_gene_variant	p.Gly395Cys,.
22	17072674	G	A	missense_variant,downstream_gene_variant	p.Pro256Leu,.
22	17072747	T	C	missense_variant,downstream_gene_variant	p.Met232Val,.
22	17072781	C	T	synonymous_variant,downstream_gene_variant	p.Pro220Pro,.
22	17073043	C	T	missense_variant,downstream_gene_variant	p.Arg133Gln,.
22	17073066	A	G	synonymous_variant,downstream_gene_variant	p.Ala125Ala,.
22	17073119	C	T	missense_variant,downstream_gene_variant	p.Val108Met,.
</pre>
				<br>
				<br>

				<b>Example 4:</b> Extracting effects, one per line
				<br>
				In order to extract effects, you can simply do something like this (notice that there are multiple columns per line because there are mutiple effects per variant):
<pre>
$ java -jar SnpSift.jar extractFields examples/test.chr22.ann.vcf CHROM POS REF ALT "ANN[*].EFFECT" 
#CHROM	POS	REF	ALT	ANN[*].EFFECT
22	17071756	T	C	3_prime_UTR_variant	downstream_gene_variant
22	17072035	C	T	missense_variant	downstream_gene_variant
22	17072258	C	A	missense_variant	downstream_gene_variant
22	17072674	G	A	missense_variant	downstream_gene_variant
22	17072747	T	C	missense_variant	downstream_gene_variant
22	17072781	C	T	synonymous_variant	downstream_gene_variant
22	17073043	C	T	missense_variant	downstream_gene_variant
22	17073066	A	G	synonymous_variant	downstream_gene_variant
22	17073119	C	T	missense_variant	downstream_gene_variant
</pre>
				Note that since some variant have more than one effect, there can be more than one "EFFECT" column.
				<br>
				<br>
				If we prefer to have one effect per line, then we can use the <code>vcfEffOnePerLine.pl</code> provided with SnpEff distribution
<pre>
$ cat examples/test.chr22.ann.vcf \
    | ./scripts/vcfEffOnePerLine.pl \
    | java -jar SnpSift.jar extractFields - CHROM POS REF ALT "ANN[*].EFFECT" \

#CHROM	POS	REF	ALT	ANN[*].EFFECT
22	17071756	T	C	3_prime_UTR_variant
22	17071756	T	C	downstream_gene_variant
22	17072035	C	T	missense_variant
22	17072035	C	T	downstream_gene_variant
22	17072258	C	A	missense_variant
22	17072258	C	A	downstream_gene_variant
22	17072674	G	A	missense_variant
22	17072674	G	A	downstream_gene_variant
22	17072747	T	C	missense_variant
</pre>
				Now we obtain one effect per line, while all other parameters in the line are repeated across mutiple lines (e.g. there are two chr22:17071756 lines, one for each variant annotation).
				<br>
				<i class="icon-hand-right"></i> Note that in SnpSift, we used <code>-</code> as input file name, which denotes STDIN.
				<br>
				<br>
				<b>Example 5:</b> Extracting genotype using genotype name instead of genotype number
				<br>
				As of SnpSift version 4.1A, you can use the genotype name in expressions:
				<br>
<pre>
$ java -jar SnpSift.jar extractFields examples/1kg.head_chr1.vcf.gz CHROM POS REF ALT "GEN[HG00096].DS" "GEN[HG00097].DS"
#CHROM    POS      REF  ALT    GEN[HG00096].DS    GEN[HG00097].DS
1         10583    G    A      0.2                 0.15
1         10611    C    G      0.05                0.75
1         13302    C    T      0.05                1.0
1         13327    G    C      0.0                 0.95
1         13957    TC   T      0.05                0.65
1         13980    T    C      0.05                0.6
1         30923    G    T      1.75                0.35
1         46402    C    CTGT   0.05                0.15
1         47190    G    GA     0.15                0.0
</pre>
				<br>
				<br>
				<b>Example 6:</b> Extracting non alphanumeric field names
				<br>
				<br>
				<i class="icon-warning-sign"></i> <code>SnpSift extractFields</code> can get confused if the VCF field has non-alphanumeric charaters in the name (e.g. <code>dbNSFP_GERP++_RS</code> has two "+" signs).
				A quick fix, it so is to change the field names in the VCF file.
				Here is an example:
				<br>
				<br>
<pre>
# Change field names in VCF
$ cat kath.vcf | sed "s/dbNSFP_GERP++/dbNSFP_GERP/g" > kath.gerp.vcf

# Use new names to extract fields
$ java -jar SnpSift.jar  extractFields kath.gerp.vcf CHROM POS REF ALT dbNSFP_GERP_RS dbNSFP_GERP_NS
#CHROM	POS	REF	ALT	dbNSFP_GERP_RS
1	142827044	G	A		
2	132914561	G	A		
7	151933217	C	A		
7	151933251	T	C		
7	151933302	T	C		
7	151945101	G	C	-0.892	
7	151945167	G	T		
7	151962176	T	A		
7	151970672	A	T		
7	151970856	T	A	3.71	
18	14183638	G	C		
18	14183710	A	G		
18	14542909	G	A		
18	14543039	T	C	-0.942	
</pre>
				
				</p>
        </section>

        <!-- Variant type
        ================================================== -->
        <section id="VariantType">
          <div class="page-header">
            <h1>11. SnpSift Variant type </h1>
          </div>
				<p class="lead">
				Adds an INFO field denoting variant type.
				</p>
				It adds "SNP/MNP/INS/DEL/MIXED" in the INFO field.
				It also adds "HOM/HET", but this last one works if there is only one sample (otherwise it doesn't make any sense).<p>
<pre>
$ java -jar SnpSift.jar varType  test.vcf | grep -v "^#" | head
20	10469	.	C	G	100.0	PASS	SNP;HOM	GT:AP	0|0:0.075,0.060
20	10492	.	C	T	100.0	PASS	SNP;HET	GT:AP	0|1:0.180,0.345
20	10575	.	C	CG	100.0	PASS	DEL;HET	GT:AP	0|1:0.000,0.000
20	10611	.	CG	C	100.0	PASS	INS;HET	GT:AP	0|1:0.000,0.010
20	10618	.	GT	TA	100.0	PASS	MNP;HET	GT:AP	0|1:0.020,0.030
</pre>
        </section>

        <!-- GWAS Catalog
        ================================================== -->
        <section id="gwasCatalog">
          <div class="page-header">
            <h1>12. SnpSift GWAS Catalog </h1>
          </div>
				<p class="lead">
				Annotate using <a href="http://www.genome.gov/gwastudies/">GWAS catalog</a><br>
				</p>
				You need the GWAS catalog file (in TXT format), which can be downloaded <a href="http://www.genome.gov/admin/gwascatalog.txt"> here </a> <p>
<pre>
$ java -jar SnpSift.jar gwasCat gwascatalog.txt test.vcf | tee test.gwas.vcf
1   1005806 rs3934834   C   T   .   PASS    AF=0.091;GWASCAT=Body_mass_index    
1   2069172 rs425277    C   T   .   PASS    AF=0.400;GWASCAT=Height 
1   2069681 rs3753242   C   T   .   PASS    AF=0.211;GWASCAT=Reasoning  
1   2392648 rs2477686   G   C   .   PASS    AF=0.745;GWASCAT=Non_obstructive_azoospermia    
1   2513216 rs734999    C   T   .   PASS    AF=0.547;GWASCAT=Ulcerative_colitis 
1   2526746 rs3748816   A   G   .   PASS    AF=0.489;GWASCAT=Celiac_disease 
1   3083712 rs2651899   T   C   .   PASS    AF=0.467;GWASCAT=Migraine   
1   3280253 rs6658356   G   A   .   PASS    AF=0.070;GWASCAT=Response_to_statin_therapy 
1   4315204 rs966321    G   T   .   PASS    AF=0.522;GWASCAT=Factor_VII 
1   5170712 rs7513590   A   G   .   PASS    AF=0.256;GWASCAT=Anthropometric_traits  
1   6279370 rs846111    G   C   .   PASS    AF=0.153;GWASCAT=QT_interval,QT_interval    
1   6631431 rs11587438  C   T   .   PASS    AF=0.906;GWASCAT=White_blood_cell_types 
1   7879063 rs2797685   C   T   .   PASS    AF=0.186;GWASCAT=Crohn_s_disease    
1   8021973 rs35675666  G   T   .   PASS    AF=0.093;GWASCAT=Ulcerative_colitis 
1   8046672 rs12727642  C   A   .   PASS    AF=0.101;GWASCAT=Celiac_disease 
1   8422676 rs2252865   T   C   .   PASS    AF=0.771;GWASCAT=Schizophrenia  
1   8526142 rs4908760   G   A   .   PASS    AF=0.630;GWASCAT=Vitiligo   
</pre>
        </section>

        <!-- dbNSFP
        ================================================== -->
        <section id="dbNSFP">
          <div class="page-header">
            <h1>13. SnpSift dbNSFP </h1>
          </div>
				<p class="lead">
				The dbNSFP is an integrated database of functional predictions from multiple algorithms (SIFT, Polyphen2, LRT and MutationTaster, PhyloP and GERP++, etc.).
				</p>
				One of the main advantages is that you can annotate using multiple prediction tools with just one command.
				This allows for faster annotations.
				<a href="https://sites.google.com/site/jpopgen/dbNSFP">Here</a> is the link to dbNSFP database website for more details.
				<p>
				<br>
				<b>Database:</b> In order to annotate using dbNSFP, you need to download the dbNSFP database and the index file. 
				dbNSFP is large (several GB) so it might take a while to download it. 
				The database is compressed (block-gzip) and <a href="http://samtools.sourceforge.net/tabix.shtml">tabix</a> indexed, so two files are required (the data *.gz file and the *.gz.tbi index file).
				<br>
				<br>
				You can download the files from SnpEff's site (remember that you need both the databse and the index file):
				<ul>
					<li> GRCh37 / hg19 (dbNSFP version 2.9 Academic): 
						<ul>
							<li> <a href="https://drive.google.com/uc?export=download&id=0B7Ms5xMSFMYlSTY5dDJjcHVRZ3M">Database</a>. Save file as <code>dbNSFP.txt.gz</code>
							<li> <a href="https://drive.google.com/uc?export=download&id=0B7Ms5xMSFMYlOTV5RllpRjNHU2s">Index</a>. Save file as <code>dbNSFP.txt.gz.tbi</code>
						</ul>
					<li> GRCh38 / hg38 (dbNSFP version 3.2 Academic): 
						<ul>
							<li> <a href="https://drive.google.com/uc?export=download&id=0B7Ms5xMSFMYlbTZodjlGUDZnTGc">Database</a>. Save file as <code>dbNSFP.txt.gz</code>
							<li> <a href="https://drive.google.com/uc?export=download&id=0B7Ms5xMSFMYlNVBJdFA5cFZRYkE">Index</a>. Save file as <code>dbNSFP.txt.gz.tbi</code>
						</ul>
				</ul>
				</p>
				<h3> dbNSFP Annotation example</h3> 
				<p>
				Here is a full example how to perform annotations
				<br>
				<br>
<pre>
# Annotate using dbNSFP
# Note that the fisr time you run the command, it will attempt to download the dbNSFP database.
java -jar SnpSift.jar dbnsfp -v myFile.vcf > myFile.annotated.vcf
</pre>

				<br>
				<i class="icon-warning-sign"></i> You can now specify which fields you want to use for annotation using the '-f' command line option followed by a comma separated list of field names.
				Defaults fields are shown when running the command without any arguments <code>java -jar SnpSift.jar dbNSFP</code>
				<br>
				<br>
				If your dbNSFP file is not in the 'default' path (where SnpEff expects it), you can specify the path to your dbNSFP file using the <code>-db</code> command line option:
				<br>
<pre>
# Annotate using dbNSFP
java -jar SnpSift.jar dbnsfp -v -db path/to/my/dbNSFP2.9.txt.gz myFile.vcf > myFile.annotated.vcf
</pre>
				<p>
				<h3> Building dbNSFP (for developers) </h3> 
				<i class="icon-warning-sign"></i> Users do <b>NOT</b> need to do this, since a pre-indexed database can be downloaded from SnpSift's site (see previous sub-section).
				These instructions are mostly for developers.
				<br>
				<br>
				You can also create dbNSFP files yourself, downloading the files from <a href="https://sites.google.com/site/jpopgen/dbNSFP">DbNsfp</a> site.
				Two files are required: 
				<ul>
					<li> A block-gzipped database file
					<li> The corresponding tabix index for the database file.
				</ul>
				<br>
				Creating a file that SnpSift can use is simple, just follow this guideline:
<pre>
# Download dbNSFP database
$ wget http://dbnsfp.houstonbioinformatics.org/dbNSFPzip/dbNSFP2.9.zip

# Uncompress
$ unzip dbNSFP2.9.zip

# Create a single file version
$ (head -n 1 dbNSFP2.9_variant.chr1 ; cat dbNSFP2.9_variant.chr* | grep -v "^#" ) > dbNSFP2.9.txt

# Compress using block-gzip algorithm
bgzip dbNSFP2.9.txt

# Create tabix index
tabix -s 1 -b 2 -e 2 dbNSFP2.9.txt.gz
</pre>
				</ul>
				</p>
				<p>
        </section>

        <!-- Split
        ================================================== -->
        <section id="Split">
          <div class="page-header">
            <h1>14. SnpSift Split </h1>
          </div>
				<p class="lead">
				Simply split (or join) VCF files. 
				Allows to create one file per chromosome or one file every N lines.
				</p>

				<i class="icon-hand-right"></i> A typical usage for this command is to: 
				<ol>
					<li> Split very large VCF files <code>SnpSift split huge.vcf</code>
					<li> Perform some CPU intensive processing in parallel using several computers or cores
					<li> Join the resulting VCF files <code>SnpSift split -j huge.000.vcf huge.001.vcf huge.002.vcf ...  > huge.out.vcf</code>.
				</ol>

				E.g.: Splitting a VCF having human variants <p>
<pre>
java -jar SnpSift.jar split myHugeVcf.vcf.gz
</pre>

				<p> Will create files myHugeVcf.1.vcf, myHugeVcf.2.vcf, ... , myHugeVcf.22.vcf, myHugeVcf.X.vcf, myHugeVcf.Y.vcf </p>
				<p> You can also specify '-l' command line option to split the file every N lines </p>
				E.g.: Split a VCF file every 10,000 lines<p>
<pre>
java -jar SnpSift.jar split -l 10000 myHugeVcf.vcf.gz
</pre>
				<p> Will create files myHugeVcf.001.vcf, myHugeVcf.002.vcf, ...  </p>
				<i class="icon-hand-right"></i> VCF header will be added to each file, so resulting files will be more than 10,000 lines.
				<br>
				<br>
				You can use <code>-j</code> (join) command line option to join a set of VCF files.
<pre>
java -jar SnpSift.jar split -j huge.000.vcf huge.001.vcf huge.002.vcf ...  > huge.out.vcf
</pre>

        </section>

        <!-- PhastCons
        ================================================== -->
        <section id="phastCons">
          <div class="page-header">
            <h1>15. SnpSift phastCons </h1>
          </div>
				<p class="lead">
				Annotate using PhastCons conservation scores.
				</p>
				<p>
				<i class="icon-hand-right"></i>  You must download PhastCons files <a href="http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/"> here </a>
				<br>
				<br>
				<i class="icon-hand-right"></i>  You also need a chromosome size file, which can be created using <code>samtools faidx</code>, or you can download it from <a href="genome.fai">here</a>
				<br>
				<br>
				Full example. 
				Most of the example deals with downloading and installing PhastCons database, which is done only once.
				The real annotation process is done in the last line.
<pre>
# Create a dir for PhastCons database
cd ~/snpEff
mkdir -p db/phastCons/

# Download all PhastCons files
cd db/phastCons/
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr1.phastCons100way.wigFix.gz                  
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr2.phastCons100way.wigFix.gz                  
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr3.phastCons100way.wigFix.gz                  
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr4.phastCons100way.wigFix.gz                  
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr5.phastCons100way.wigFix.gz                  
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr6.phastCons100way.wigFix.gz                  
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr7.phastCons100way.wigFix.gz                  
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr8.phastCons100way.wigFix.gz                  
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr9.phastCons100way.wigFix.gz                  
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr10.phastCons100way.wigFix.gz                 
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr11.phastCons100way.wigFix.gz                 
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr12.phastCons100way.wigFix.gz                 
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr13.phastCons100way.wigFix.gz                 
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr14.phastCons100way.wigFix.gz                 
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr15.phastCons100way.wigFix.gz                 
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr16.phastCons100way.wigFix.gz                 
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr17.phastCons100way.wigFix.gz                 
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr18.phastCons100way.wigFix.gz                 
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr19.phastCons100way.wigFix.gz                 
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr20.phastCons100way.wigFix.gz                 
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr21.phastCons100way.wigFix.gz                 
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chr22.phastCons100way.wigFix.gz                 
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chrM.phastCons100way.wigFix.gz                  
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chrX.phastCons100way.wigFix.gz                  
wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/phastCons100way/hg19.100way.phastCons/chrY.phastCons100way.wigFix.gz 

# Create a chromosome size file and name it "genome.fai"
samtools faidx path/to/genome/hg19.fa.gz
cp path/to/genome/hg19.fa.gz.fai ./genome.fai

# Now we are ready to annotate
java -Xmx4g -jar SnpSift.jar phastCons ~/snpEff/db/phastCons file.vcf > file.phastCons.vcf
</pre>
				<br>
				<br>
				You can annotated intervals using BED files and <code>-bed</code> command line option.
				In the output BED formatted intervals, the score column (fifth column), is the average conservation score of all bases within the interval.
				<br>
				<br>
				It is possible to extract sub-intervals having at least 'minScore' conservation score and 'len' length by using <code>-minScore score</code> and <code>-extract len</code> command line options.
				For instance, the following command:
<pre>
java -jar SnpSift.jar phastCons -minScore 0.8 -extract 10 -bed path/to/phastCons/dir input.bed
</pre>
				extracts all subintervals from each line in <code>input.bed</code>, that has at least <code>10</code> bases length and a conservation score of <code>0.8</code>
				</p>

				
        </section>

        <!-- Concordance
        ================================================== -->
        <section id="concordance">
          <div class="page-header">
            <h1>16. SnpSift Concordance </h1>
          </div>
				<p class="lead">
				Calculate concordance between two VCF files.
				</p>
				<p>
				This is typically used when you want to calculate concordance between a genotyping experiment and a sequencing experiment.
				<br>
				For instance, you sequenced several samples and, as part of a related experiment or just as quality control, you also genotype the same samples using a genotyping array.
				Now you want to compare the two experiments. 
				Ideally there would be no difference between the variants from genotyping and sequencing, but this is hardly the case in real world.
				<br>
				You can use <code>SnpSift concordance</code> to measure the differences between the two experiments.
				<br>
				<br>
				<i class="icon-warning-sign"></i> It is assumed that both VCF files are sorted by chromosome and position.
				<br>
				<br>
				<i class="icon-warning-sign"></i>Sample names are defined in '#CHROM' line of the header section. 
				Concordance is calculated only if sample label matches in both files.
				<br>
				Example: 
<pre>
$ java -Xmx1g -jar SnpSift.jar concordance -v genotype.vcf sequencing.vcf > concordance.txt
00:00:00.000	Indexing file 'genotype.vcf'
	index:	MT	460030998
	index:	1	19705
		1 / 2	45170805 / 45174315
		2 / 3	77052081 / 77055591
		3 / 4	104065531 / 104069041
		4 / 5	124098372 / 124101881
		5 / 6	146535292 / 146538802
		6 / 7	184793526 / 184797035
		7 / 8	206156508 / 206160018
		8 / 9	223072816 / 223076326
		9 / 10	242315995 / 242319505
		10 / 11	261053789 / 261057299
		11 / 12	290190553 / 290194063
		12 / 13	312869636 / 312873146
		13 / 14	321966539 / 321970049
		14 / 15	336131317 / 336134827
		15 / 16	350871669 / 350875179
		16 / 17	368900523 / 368904032
		17 / 18	391305860 / 391309369
		18 / 19	398932237 / 398935747
		19 / 20	425219198 / 425222708
		20 / 21	437022008 / 437025517
		21 / 22	442563678 / 442567188
		22 / X	451783418 / 451786927
		X / Y	459553691 / 459557200
		Y / MT	459588787 / 459592296
00:00:01.137	Open VCF file 'genotype.vcf'
00:00:01.141	Open VCF file 'sequencing.vcf'
00:00:01.176	Chromosome: '1'
00:00:02.127		1:1550992	1:1528859
00:00:02.739		1:2426313	1:2389636
...
00:02:13.780		1:248487058	1:248471945
</pre>
				</p>

				<h3>Output</h3>
				<p>
				SnpSif's concordance output is written to STDOUT and two files.
				For instance the command <code>java -jar SnpSift.jar concordance -v genotype.vcf sequencing.vcf</code> will write:
				<ul>
					<li> Concordance by variant: Written to STDOUT
					<li> Concordance by sample: Written to <code>concordance_genotyping_sequencing.by_sample.txt</code>
					<li> Summary:  Written to <code>concordance_genotyping_sequencing.summary.txt</code>
				</ul>
				</p>
				<b>Concordance by variant</b>
				<p>
				This sections is a table showing concordance details for every entry (chr:position) that both files have in common.
				E.g.:
<pre>
chr  pos     ref  alt  change_0_0  change_0_1  change_0_2  change_1_0  change_1_1  change_1_2  change_2_0  change_2_1  change_2_2  missing_genotype_genotype  missing_genotype_sequencing
1    865584  G    A        508         0           0           0           2           0           0           0           0           0                                 5
1    865625  G    A        512         0           0           0           1           0           0           0           0           0                                 1
1    865628  G    A        511         0           0           0           2           0           0           0           0           0                                 1
1    865665  G    A        495         0           0           0           4           0           0           0           0           0                                17
1    865694  C    T        428         0           0           0          82           0           0           0           4           0                                 0
</pre>
				<br>
				<br>
				Each genotype is coded according to the number of ALT variants. i.e.:
				<ul>
					<li> '0/0' (homozygous reference) is coded as '0'
					<li> '0/1' or '1/0' (heterozygous ALT) coded as '1'
					<li> '1/1' (homozygous ALT) is coded as '1'
				</ul>
				So the column "change_X_Y" on the table shows how many genotypes coded 'X' in the first VCF, changed to 'Y' in the second VCF.
				For example, 'change_0_1' counts the number of "homozygous reference in genotype.vcf" that changed to "heterozygous ALT in sequencing.vcf".
				Or 'change_2_2' counts the number of "homozygous ALT" that did not change (in both files they are '2').
				<br>
				<br>
				A few rules apply:
				<ul>
					<li> If a VCF entry (chr:pos) is present in only one of the files, obviously we cannot calculate concordance, so it is ignored.
					<li> If a VCF entry (chr:pos) has more than one ALT it is ignored. This means that non-biallelic variants are ignored.
					<li> If, for the same chr:pos, REF field is different between the two files, then the entry is ignored.
					<li> If, for the same chr:pos, ALT field is different between the two files, then the entry is ignored.
				</ul>
				</p>
				<b>Concordance by sample</b>
				<p>
				This section shows details in the same format as the previous section.
				Here, concordance metrics are shown aggregated for each sample.
				E.g.:
<pre>
# Totals by sample
sample  change_0_0  change_0_1  change_0_2  change_1_0  change_1_1  change_1_2  change_2_0  change_2_1  change_2_2  missing_genotype_genotype  missing_genotype_sequencing
ID_003  79          0           0           1           8           0           0           0           2           1                          1
ID_004  83          0           0           1           2           0           0           0           5           0                          1
ID_005  80          0           0           0           7           0           0           0           4           1                          0
ID_006  79          0           0           0           5           0           0           0           6           0                          2
ID_008  81          0           0           0           4           0           0           0           4           0                          3
ID_009  80          0           0           0           7           0           0           0           3           0                          2
ID_012  74          0           0           0           10          0           0           0           1           0                          7
ID_013  79          1           0           0           4           0           0           0           5           0                          3
ID_018  84          0           0           0           5           0           0           0           3           0                          0
...
</pre>
				</p>
				<b>Summary</b>
				<p>
				Summary file contains overall information and errors.
				Here is an example of a summary file:
<pre>
$ cat concordance_genotyping_sequencing.summary.txt
Number of samples:
    929    File genotype.vcf
    583    File sequencing.vcf
    514    Both files
Errors:
	ALT field does not match	19
</pre>
				The header indicates that one file ('genotype.vcf') has 929 samples, the other file has 583 and there are 514 matching sample IDs in both files.
				<br>
				At the end of the file, a footer shows the total for each column followed by number of possible errors (or mismatches).
				In this case the were 19 ALT fields that did not match between 'genotype.vcf' and 'sequencing.vcf'. 
				This can happen, for instance, when there are INDELs, which cannot be detected by genotyping arrays.
				<br>
				<br>
				<i class="icon-hand-right"></i> Summary messages are shown to STDERR if you use verbose mode (command line option <code>-v</code>).
				</p>
        </section>

        <!-- Private
        ================================================== -->
        <section id="private">
          <div class="page-header">
            <h1>17. SnpSift Private </h1>
          </div>
				<p class="lead">
				Annotate if a variant is private to a family.
				</p>
				<p>
				A <code>Private=Family_ID</code> is added to a variant's INFO field, if the variant is only found in one family.
				A TFAM file (see PLINK's documentation) specifies a mapping from sample IDs to family IDs.
				<br>
				E.g.:
<pre>
$ java -jar SnpSift.jar private pheotypes.tfam imp.ann.vcf > imp.ann.private.vcf
</pre>
				<br>
				An annotated variant may look like this:
<pre>
1   1005806 rs3934834   C   T   .   PASS    AF=0.091;..;<b>Private=Family_47</b>
</pre>
				This indicates that the variant is only found in members of <code>Family_47</code>, according to the definitions in <code>pheotypes.tfam</code>.
				</p>
        </section>

        <!-- Vcf2Tped
        ================================================== -->
        <section id="vcf2tped">
          <div class="page-header">
            <h1>18. SnpSift Vcf2Tped </h1>
          </div>
				<p class="lead">
				Convert from VCF to PLINK's TPED file format.
				</p>
				<p>
				The <code>vcf2tped</code> command uses a VCF and a TFAP file as input, creating a TPED and a consolidated TFAM as outputs.
				<br>
				<br>
				Command line options are:
<pre>
$ java -jar SnpSift.jar vcf2tped
SnpSift version 1.9d (build 2013-04-26), by Pablo Cingolani
Usage: java -jar SnpSift.jar vcf2tped [options] file.tfam file.vcf outputName
Options:
	-f             : Force. Overwrite new files if they exist. Default: false
	-onlySnp       : Use only SNPs when converting VCF to TPED. Default: false
	-onlyBiAllelic : Use only bi-allelic variants. Default: false
	-useMissing    : Use entries with missing genotypes (otherwise they are filtered out). Default: false
	-useMissingRef : Use entries with missing genotypes marking them as 'reference' instead of 'missing'. Default: false
Parameters:
	file.tfam      : File with genotypes and groups information (in PLINK's TFAM format)
	file.vcf       : A VCF file (variants and genotype data)
	outputName     : Base name for the new TPED and TFAM files.
</pre>
				<br>
				<br>
				<code>vcf2tped</code> command supports the following features:

				<ul>
					<li> Output a TPED file:
						<ul>
							<li> Only samples present in both the input TFAM and the input VCF files are in the output TPED.
							<li> Bi-allelic filter: <code>-onlyBiAllelic</code> option filters out non bi-allelic variants.
							<li> Non SNP variants (InDels, MNPs, etc):
								<ul>
									<li> InDels and other non-SNP variants are converted for "fake" SNPs (some programs have problems handling non-SNP variants).
									<li> <code>-onlySnp</code> option filters out non SNP variants.
								</ul>
							<li> Missing variants:
								<ul>
									<li> Variants having missing data are filtered out by default.
									<li> <code>-useMissing</code> uses missing variants in TPED file.
									<li> <code>-useMissingRef</code> Converts missing variants to reference genotype.
								</ul>
						</ul>
					<li> Output TFAM file:
						<ul>
							<li> Only samples present in both the input TFAM and the input VCF files are in the output TFAM.
							<li> Samples are re-ordered to have the same order as the VCF file
						</ul>
				</ul>
				</p>
        </section>

        <!-- Intersect
        ================================================== -->
        <section id="intersect">
          <div class="page-header">
            <h1>19. SnpSift Intersect </h1>
          </div>
				<p class="lead">
				This command intersects several intervals files (e.g. BED, BigBed, TXT) and produces a result of all intersections.
				</p>
				<p>
				<br>
				A typical usage example is to create a consensus of peaks from several Chip-Seq experiments.
				<br>
				<br>
				Algorithm: This command creates one interval forest for each input file. 
				For every interval in all input files, finds all intervals that intersect at least <code>minOverlap</code> bases (default 1 base).
				If there are at least <code>cluster</code> number of intersecting intervals it creates a consensus interval from the intersections (or <code>union</code>) of all intervals found.
				The consensus interval, if any, is shown as result.
				<p>
				<br>
				Command line options:
<pre>
$ java -jar SnpSift.jar intersect
SnpSift version 1.9d (build 2013-04-26), by Pablo Cingolani
Usage: java -jar SnpSift.jar [options] file_1.bed file_2.bed ... file_N.bed
Options:
	-minOverlap <num> : Minimum number of bases that two intervals have to overlap. Default : 0
	-cluster <num>    : An interval has to intersect at least 'num' intervals (from other files) to be considered. Default: 0
	-intersect        : Report the intersection of all intervals. Default: false
	-union            : Report the union of all intervals. Default: true
</pre>
				</p>
        </section>

        <!-- RmInfo
        ================================================== -->
        <section id="rmInfo">
          <div class="page-header">
            <h1>20. SnpSift RmInfo </h1>
          </div>
				<p class="lead">
				This command removes INFO fields from a VCF file (i.e. removes annotations)
				</p>
				<p>
				Removing INFO fields is usually done because you want to re-annotate the VCF file, thus removing old INFO fields in order to add new ones later.
				<br>
				<br>
				SnpEff & SnpSift only add annotations and do not change currentones. 
				So, in order to re-annotate a file, you should first remove theold annotations and then re-annotate.
				<br>
				The reason for thisbehavioris simply because replacing annotationvalues is considered a bad practice. 
				Imagine that you have a VCF entry in your re-annotated file having the value "AA=1": How do you know if this is from the old annotations or from the new ones? 
				This confusion often leads to problems in downstream steps of your pipelines, so it's betterto avoid the problem by first removing all the previous annotations and then adding the new ones.
				<br>
				<br>
				Usage example:
<pre>
$ cat test.snpeff.vcf 
#CHROM	POS	ID	REF	ALT	QUAL	FILTER	INFO
1	734462	1032	G	A	.	s50	AC=348;EFF=DOWNSTREAM(MODIFIER|||||RP11-206L10.8|processed_transcript|NON_CODING|ENST00000447500||1),INTRON(MODIFIER|||||RP11-206L10.6|processed_transcript|NON_CODING|ENST00000429505|1|1)

$ java -jar SnpSift.jar rmInfo test.snpeff.vcf EFF
#CHROM	POS	ID	REF	ALT	QUAL	FILTER	INFO
1	734462	1032	G	A	.	s50	AC=348
</pre>
				</p>
        </section>

        <!-- GeneSets
        ================================================== -->
        <section id="geneSets">
          <div class="page-header">
            <h1>21. SnpSift GeneSets </h1>
          </div>
				<p class="lead">
				Annotating GeneSets, such as Gene Ontology (GO), KEGG, Reactome, etc.; can be quite useful to find significant variants.
				</p>
				<p>
				Gene set annotations can be added to a SnpEff annotated file using <code>SnpSift geneSets</code> command.
				The VCF file must be annotated using <code>SnpEff</code> before perforimg Gene Sets annotations.
				This is because we must know which gene the variant affects).
				<br>
				<br>
				<i class="icon-hand-right"></i> You can download MSigDb from <a href="http://www.broadinstitute.org/gsea/msigdb">Broad Institute</a>
				<br>
				<br>
				Usage example:
<pre>
$ java -jar SnpSift.jar geneSets -v db/msigDb/msigdb.v3.1.symbols.gmt test.ann.vcf > test.eff.geneSets.vcf
00:00:00.000	Reading MSigDb from file: 'db/msigDb/msigdb.v3.1.symbols.gmt'
00:00:01.168	Done. Total:
	8513 gene sets
	31847 genes
00:00:01.168	Annotating variants from: 'test.ann.vcf'
00:00:01.298	Done.
# Summary
#	gene_set	gene_set_size	variants
#	ACEVEDO_METHYLATED_IN_LIVER_CANCER_DN	940	8
#	CHR1P36	504	281
#	KEGG_OLFACTORY_TRANSDUCTION	389	8
#	REACTOME_GPCR_DOWNSTREAM_SIGNALING	805	8
#	REACTOME_OLFACTORY_SIGNALING_PATHWAY	328	8
...
#	REACTOME_SIGNALING_BY_GPCR	920	8

$ cat test.eff.geneSets.vcf
##INFO=&lt;ID=MSigDb,Number=.,Type=String,Description="Gene set from MSigDB database (GSEA)">
1	69849	.	G	A	454.73	PASS	AC=33;EFF=STOP_GAINED(HIGH|NONSENSE|tgG/tgA|W253*|305|OR4F5|protein_coding|CODING|ENST00000335137|1|1);MSigDb=ACEVEDO_METHYLATED_IN_LIVER_CANCER_DN,CHR1P36,KEGG_OLFACTORY_TRANSDUCTION,REACTOME_GPCR_DOWNSTREAM_SIGNALING,REACTOME_OLFACTORY_SIGNALING_PATHWAY,REACTOME_SIGNALING_BY_GPCR
</pre>
				</p>
        </section>

        <!-- Genotypes
        ================================================== -->
        <section id="gt">
          <div class="page-header">
            <h1>22. SnpSift GT </h1>
          </div>
				<p class="lead">
				Compress genotype calls, reducing the overall size of the VCF file.
				</p>
				<p>
				This is intended for compressing very large VCF in very large sequencing projects (e.g. thousands of samples).<br>
				<br>
				<i class="icon-hand-right"></i> For instance, we've reduced 1Tb (1,000 Gb) VCF file to roughly 1Gb in a project that has over 10,000 samples. 
				<br>
				<br>
				The underlying idea is quite simple. 
				In large re-sequenceing projects most of the variants are singletons. 
				This means that most variants are present in only one of the samples.
				For those variants, you have thousands of samples that are homozygous reference (i.e. genotype entry is "0/0") and one that is a variant (e.g. '0/1' or '1/1').
				<br>
				A trivial way to compress these VCF entries is just to state which sample has non-reference information.
				Intuitively, this is similar to the way used to represent sparse matrices (only store non-zero elements).
				<br>
				<br>
				<code>SnpSift gt</code> creates three INFO fields. These three files are composed of comma separated indexes of samples having:
				<ul>
					<li> HE: Indicated heterozygous variants (i.e. '0/1').
					<li> HO: Indicated homozygous variants (i.e. '1/1').
					<li> NA: Indicated missing genotype data (i.e. './.').
				</ul>
				<br>
				You can use <code> -u </code> command line option to uncompress.
				<br>
				E.g.:
<pre>
$ cat test.vcf
#CHROM  POS     ID  REF  ALT  QUAL  FILTER  INFO  FORMAT  Sample_1  Sample_2  Sample_3  Sample_4  Sample_5  Sample_6  Sample_7  Sample_8  Sample_9  Sample_10  Sample_11  Sample_12  Sample_13  Sample_14  Sample_15
1       861276  .   A    G    .     PASS    AC=1  GT      0/0       1/1       0/0       0/0       0/0       0/0       0/0       0/0       0/0       0/0        0/0        0/0        0/0        0/0        0/0

#---
# Compress genotypes
#---
$ java -jar SnpSift.jar gt test.vcf | tee test.gt.vcf
##INFO=&lt;ID=HO,Number=.,Type=Integer,Description="List of sample indexes having homozygous ALT genotypes">
##INFO=&lt;ID=HE,Number=.,Type=Integer,Description="List of sample indexes having heterozygous ALT genotypes">
##INFO=&lt;ID=NA,Number=.,Type=Integer,Description="List of sample indexes having missing genotypes">
#CHROM  POS     ID  REF  ALT  QUAL  FILTER  INFO        FORMAT  Sample_1  Sample_2  Sample_3  Sample_4  Sample_5  Sample_6  Sample_7  Sample_8  Sample_9  Sample_10  Sample_11  Sample_12  Sample_13  Sample_14  Sample_15
1       861276  .   A    G    .     PASS    AC=1;HO=1

#---
# Uncompress genotypes (command line option '-u')
#---
$ java -jar SnpSift.jar gt -u test.gt.vcf 
#CHROM  POS     ID  REF  ALT  QUAL  FILTER  INFO  FORMAT  Sample_1  Sample_2  Sample_3  Sample_4  Sample_5  Sample_6  Sample_7  Sample_8  Sample_9  Sample_10  Sample_11  Sample_12  Sample_13  Sample_14  Sample_15
1       861276  .   A    G    .     PASS    AC=1  GT      0/0       1/1       0/0       0/0       0/0       0/0       0/0       0/0       0/0       0/0        0/0        0/0        0/0        0/0        0/0
</pre>
				<br>
				<br>
				<i class="icon-warning-sign"></i> This is lossy compression. Note that only GT informations is compressed, all other information in genotype field is lost.
				</p>
        </section>

        <!-- VcfCheck
        ================================================== -->
        <section id="vcfCheck">
          <div class="page-header">
            <h1>23. SnpSift VcfCheck </h1>
          </div>
				<p class="lead">
				Perform some basic check ups on VCF files to spot common problems.
				</p>
				<p>
				<code>SnpSift vcfCheck</code> checks for some common problems where VCF files are not following the specification.
				Given that many common VCF problems cause analysis tools and pipelines to behave unexpectedly, this command is intended as a simple debugging tool.
				<br>
				E.g.:
<pre>
$ java -jar SnpSift.jar vcfCheck bad.vcf 

WARNING: Malformed VCF entryfile 'bad.vcf', line 7:
	Entry  : 3	148885779	.	A	ATT,AT	999.0	PASS	UK10KWES_AC=0,0;MDV=94
	Errors :
		INFO filed 'UK10KWES_AC' has 'Number=1' in header, but it contains '2' elements.
		Cannot find header for INFO field 'MDV'

WARNING: Malformed VCF entryfile 'bad.vcf', line 14:
	Entry  : 3	148890104	.	TCA	T	.	.	.
	Errors :
		File is not sorted: Position '3:148890104' after position '3:148890105'

</pre>
				<br>
				</p>
        </section>
      </div>
    </div>

  </div>



    <!-- Footer
    ================================================== -->
      <footer>
        <p class="text-center">&copy; <a class="body" href="http://www.linkedin.com/in/pablocingolani">Pablo Cingolani</a></p>
      </footer>


    <!-- Placed at the end of the document so the pages load faster -->
    <script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
    <script src="js/jquery.js"></script>
    <script src="js/bootstrap-transition.js"></script>
    <script src="js/bootstrap-alert.js"></script>
    <script src="js/bootstrap-modal.js"></script>
    <script src="js/bootstrap-dropdown.js"></script>
    <script src="js/bootstrap-scrollspy.js"></script>
    <script src="js/bootstrap-tab.js"></script>
    <script src="js/bootstrap-tooltip.js"></script>
    <script src="js/bootstrap-popover.js"></script>
    <script src="js/bootstrap-button.js"></script>
    <script src="js/bootstrap-collapse.js"></script>
    <script src="js/bootstrap-carousel.js"></script>
    <script src="js/bootstrap-typeahead.js"></script>
    <script src="js/bootstrap-affix.js"></script>

    <script src="js/holder/holder.js"></script>
    <script src="js/google-code-prettify/prettify.js"></script>

    <script src="js/application.js"></script>



  </body>
</html>
